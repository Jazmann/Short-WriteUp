(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 10.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[    200810,       6158]
NotebookOptionsPosition[    186855,       5782]
NotebookOutlinePosition[    190930,       5900]
CellTagsIndexPosition[    189939,       5871]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{

Cell[CellGroupData[{
Cell["\<\
Color Spaces and Information Storage for Computer Vision Processing \
\>", "Chapter",
 CellChangeTimes->{3.633112870092998*^9}],

Cell[CellGroupData[{

Cell["Constructing a New Color Space  ", "Section",
 CellChangeTimes->{3.633112883268569*^9},
 CellTags->"sec:ConstructingANewColorSpace"],

Cell["\<\
In order to construct a new color space, we need to consider the coordinate \
system of the new color space, the orientation of the new color space, and \
the fidelity of the discrete representation of the axes. \
\>", "Text"],

Cell["\<\
The first consideration is most easily decided; because there\
\[CloseCurlyQuote]s little obvious advantage otherwise, we choose a Cartesean \
coordinate system as this allows for a straightforward transformation \
involving only rotation, translation and scaling. Because \
we\[CloseCurlyQuote]re interested in the color information in the image, it\
\[CloseCurlyQuote]s useful to design the color space so there is a luminosity \
axis. This choice determines two of three rotational degrees of freedom, as \
will be discussed below. \
\>", "Text"],

Cell["\<\
As for the discrete representation of the axes, it\[CloseCurlyQuote]s desired \
that all the information captured pertaining to a hand should be preserved; \
all other information is irrelevant. However, here we\[CloseCurlyQuote]ll \
consider only the effect of a rotation and scaling on the discrete \
representation. \
\>", "Text"],

Cell[CellGroupData[{

Cell["Camera RGB and Normalization for Discrete Range  ", "Subsection",
 CellChangeTimes->{3.633112898434314*^9},
 CellTags->"sec:CameraRGB"],

Cell["\<\
Due to the iPhone hardware being locked down at the application level, we do \
not have access to the raw camera feed. We do, however, have access to the \
post\[Hyphen]processing (color\[Hyphen]rebalanced and white\[Hyphen]point\
\[Hyphen]corrected) 8\[Hyphen]bit RGB image data. \
\>", "Text"],

Cell["\<\
Because we\[CloseCurlyQuote]re searching for particular points in the real \
color space \[LongDash] which, being a continuous function, is infinite \
dimensional \[LongDash] there is a possibility in the future that larger \
multi\[Hyphen]channel color spaces will be much more common, such as the 8\
\[Hyphen]channel color spaces currently in development. Though most such \
cameras are primarily designed for post\[Hyphen]production editing for still \
pictures and film (e.g. changing the lighting independent of the scene), as \
well as visual effects, the possibilities for computer vision are exciting. \
However, computer vision tasks are computationally intensive, and more often \
than not require operation in real time, so there is a natural inclination to \
shy away from large data sets in practical computer vision applications; many \
tasks are done in grayscale or single\[Hyphen]channel processing to expedite \
the process. \
\>", "Text"],

Cell["\<\
As such, there is a need to develop techniques which keep the relevant \
information while quickly and efficiently discarding the irrelevant \
information. This is true for the RGB space at the moment, and the aim of \
this first part of the work. \
\>", "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Rotation Matrix ", "Subsection",
 CellChangeTimes->{{3.6331194175907183`*^9, 3.633119433418542*^9}}],

Cell["\<\
 Any rotation about an axis can be represented by a 3x3 square matrix in a 3D \
space. Since they are invertible, they\[CloseCurlyQuote]re guaranteed to be \
non\[Hyphen]singular. However, as there are many ways in which to rotate an \
object from one position to another, or use a combination of different \
rotations to get to the same point, they aren\[CloseCurlyQuote]t necessarily \
unique. For this application, we require rotation about three different axes, \
which can be expressed thus: \
\>", "Text",
 CellChangeTimes->{{3.633119408988227*^9, 3.633119438088511*^9}},
 CellTags->"sec:RotationMatrix"],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         SubscriptBox["1", 
          StyleBox["x", "TI"]], "(", "\[Theta]", ")"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell["1", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"cos", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"-", "\n", "sin", "\n", 
                "\[Theta]"}], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"sin", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"cos", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         SubscriptBox["\[Null]", 
          StyleBox["y", "TI"]], "(", "\[Theta]", ")"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell[BoxData[{"cos", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"sin", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["1", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData[{"-", "\n", "sin", "\n", 
                "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"cos", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         SubscriptBox["\[Null]", 
          StyleBox["z", "TI"]], "(", "\[Theta]", ")"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell[BoxData[{"cos", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"-", "\n", "sin", "\n", 
                "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData[{"sin", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell[BoxData[{"cos", "\n", "\[Theta]"}], "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]], Cell[TextData[{
                " ",
                Cell["1", "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "Any rotation which orients the RGB color space such that one of the new \
axes lies along the luminosity direction is sufficient; a rotation which \
aligns the L axis along the luminosity direction is produced by a rotation of \
",
 Cell[BoxData[
  FormBox[
   FractionBox["\[Pi]", "4"], TraditionalForm]], "InlineFormula"],
 " about the red (",
 StyleBox["R", "TB"],
 ") axis, followed by a rotation of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"arctan", 
    FractionBox["1", 
     SqrtBox["2"]]}], TraditionalForm]], "InlineFormula"],
 " about the green (",
 StyleBox["G", "TB"],
 ") axis. This leaves one free rotational degree of freedom about the L axis. \
The resulting rotation matrix is given by:  "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SubscriptBox["\[Null]", 
    StyleBox[
     RowBox[{"x", "y", "z"}], "TI"]], 
   RowBox[{"(", "\[Theta]", ")"}], "\[LongEqual]", 
   RowBox[{"(", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             FractionBox["1", 
              SqrtBox["3"]], "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             FractionBox["1", 
              SqrtBox["3"]], "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             FractionBox["1", 
              SqrtBox["3"]], "DisplayFormula"], TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"-", 
              SqrtBox[
               FractionBox["2", "3"]], 
              RowBox[{"\[Theta]", "+", "6"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              SqrtBox[
               FractionBox["2", "3"]], "cos", 
              RowBox[{"(", "\[Theta]", ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"-", 
              SqrtBox[
               FractionBox["2", "3"]], 
              RowBox[{"6", "-", "\[Theta]"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"-", 
              SqrtBox[
               FractionBox["2", "3"]], "cos", 
              RowBox[{"(", 
               RowBox[{"\[Theta]", "+", "6"}], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"-", 
              SqrtBox[
               FractionBox["2", "3"]], "sin", 
              RowBox[{"(", "\[Theta]", ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              SqrtBox[
               FractionBox["2", "3"]], "cos", 
              RowBox[{"(", 
               RowBox[{"6", "-", "\[Theta]"}], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]}
       }], TraditionalForm]]], ")"}]}], TraditionalForm]], "NumberedEquation",\

 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "Where ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " is the remaining rotational degree of freedom. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "Using the standard rotation matrices, we get a luminosity axis which spans \
the range ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", 
    SqrtBox["3"]}], TraditionalForm]], "InlineFormula"],
 ". However, the length of the two remaining axes are dependent on the value \
of ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " used. This is a problem because, ultimately, we want the axes to fit in a \
range of an appropriate data type. It would be more useful to have a matrix \
which provided the specified rotation and scaled the axis to known lengths. \
In the case of the luminosity, this is straightforward; simply divide by ",
 Cell[BoxData[
  FormBox[
   SqrtBox["3"], TraditionalForm]], "InlineFormula"],
 ". In the case of the other two axes, we need an explicit form for the \
lengths of the axis resulting from the rotation. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "Because the absolute values of the axes in the color space have no meaning, \
we\[CloseCurlyQuote]re only interested in the position along the axis \
relative to its start and end, equivalent to talking about the position in \
the axis relative to ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", "1"}], TraditionalForm]], "InlineFormula"],
 ", compared to about ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", "255"}], TraditionalForm]], "InlineFormula"],
 " in unsigned, 8\[Hyphen]bit integers. The upside is that if we\
\[CloseCurlyQuote]re rotating the cube about its corner, \
we\[CloseCurlyQuote]re interested in the minimum and maximum values possible \
along the new axis direction, which will correspond to a corner of the RGB \
cube. With the L axis aligned along the luminosity direction, the range of \
the L axis is 0 to ",
 Cell[BoxData[
  FormBox[
   SqrtBox["3"], TraditionalForm]], "InlineFormula"],
 ". The x and y axes are symmetrical, spanning a range centered on 0. The \
range of their values is dependent upon the remaining degree of freedom. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "We need to know, in each of the axes, how far out each point is. Because we\
\[CloseCurlyQuote]re effectively rotating a hexagon, whatever the answer is, \
we know the function is going to be periodic, repeating every ",
 Cell[BoxData[
  FormBox[
   FractionBox["\[Pi]", "3"], TraditionalForm]], "InlineFormula"],
 " radians, so we only have to solve it in the ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", 
    FractionBox["\[Pi]", "3"]}], TraditionalForm]], "InlineFormula"],
 " region and then generalize. First we take the coordinates of the RGB cube \
and perform the rotation to find the values in the new color space. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "The extent of the new axis is found by taking the maximum and minimum \
values of each row, i.e. the extreme corner positions relative to each new \
axis. An additional symmetry of the hexagonal projection of the RGB cube \
allows us to say that \[LongDash] whatever functional form is taken by one of \
the ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " dependant ranges \[LongDash] the other can be found by a simple phase \
shift. So, recognizing that the minimum value is simply ",
 Cell[BoxData[
  FormBox[
   RowBox[{"-", "1"}], TraditionalForm]], "InlineFormula"],
 " times the maximum, we have simplified the problem to solving: "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[
  RowBox[{"max", 
   RowBox[{"(", 
    RowBox[{"\[PlusMinus]", 
     FractionBox[
      RowBox[{"sin", "(", "\[Theta]", ")"}], 
      SqrtBox["6"]], "\[PlusMinus]", 
     FractionBox[
      RowBox[{"cos", "(", "\[Theta]", ")"}], 
      SqrtBox["2"]], ",", "\[PlusMinus]", 
     SqrtBox[
      FractionBox["2", "3"]], "sin", 
     RowBox[{"(", "\[Theta]", ")"}]}], ")"}], "  ", "Where", "  ", "0", 
   "\[LessEqual]", "\[Theta]", "\[LessEqual]", 
   FractionBox["\[Pi]", "3"]}], TraditionalForm]], "NumberedEquation",
 TaggingRules:>{"Tex Macro Name" -> "matrix"},
 CellTags->"eq:AxisRangeMinMax"],

Cell[TextData[{
 "A graphical representation of the problem can be seen in Figure\
\[NonBreakingSpace]",
 
 CounterBox["Section", "eq:YabCube"],
 " . "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "In the range ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", 
    FractionBox["\[Pi]", "3"]}], TraditionalForm]], "InlineFormula"],
 ", both sin and cos are positive, therefore the axis ranges are given by the \
following: "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 Cell[BoxData[
  FormBox[Cell[BoxData[
    FormBox[GridBox[{
       {Cell["  "], Cell[" Min  "], Cell[" Max  "]},
       {Cell[" L  "], Cell[TextData[{
         " ",
         Cell["0", "InlineFormula"],
         "  "
        }]], Cell[TextData[{
         " ",
         Cell[BoxData["3"], "InlineFormula"],
         "  "
        }]]},
       {Cell[" Ca  "], Cell[TextData[{
         " ",
         Cell[BoxData[{"-", "\n", 
          SqrtBox[
           FractionBox["2", "3"]], "\n", "cos", "\n", 
          RowBox[{"(", 
           RowBox[{"6", "-", 
            RowBox[{"(", 
             RowBox[{
              RowBox[{"(", 
               RowBox[{"\[Theta]", "-", "6"}], ")"}], "mod", 
              FractionBox["\[Pi]", "3"]}], ")"}]}], ")"}]}], "InlineFormula"],
         
         " "
        }]], Cell[TextData[{
         " ",
         Cell[BoxData[{
          SqrtBox[
           FractionBox["2", "3"]], "\n", "cos", "\n", 
          RowBox[{"(", 
           RowBox[{"6", "-", 
            RowBox[{"(", 
             RowBox[{
              RowBox[{"(", 
               RowBox[{"\[Theta]", "-", "6"}], ")"}], "mod", 
              FractionBox["\[Pi]", "3"]}], ")"}]}], ")"}]}], "InlineFormula"],
         
         " "
        }]]},
       {Cell[" Cb  "], Cell[TextData[{
         " ",
         Cell[BoxData[{"-", "\n", 
          SqrtBox[
           FractionBox["2", "3"]], "\n", "cos", "\n", 
          RowBox[{"(", 
           RowBox[{"6", "-", 
            RowBox[{"(", 
             RowBox[{"\[Theta]", "mod", 
              FractionBox["\[Pi]", "3"]}], ")"}]}], ")"}]}], "InlineFormula"],
         
         " "
        }]], Cell[TextData[{
         " ",
         Cell[BoxData[{
          SqrtBox[
           FractionBox["2", "3"]], "\n", "cos", "\n", 
          RowBox[{"(", 
           RowBox[{"6", "-", 
            RowBox[{"(", 
             RowBox[{"\[Theta]", "mod", 
              FractionBox["\[Pi]", "3"]}], ")"}]}], ")"}]}], "InlineFormula"],
         
         " "
        }]]}
      }], TraditionalForm]]], TraditionalForm]], "InlineFormula"],
 " "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["The lengths of the axis after rotation are given by: ", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["L",
    FontSlant->"Bold"], 
   RowBox[{"(", "\[Theta]", ")"}], "\[LongEqual]", 
   RowBox[{"(", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             SqrtBox["3"], "DisplayFormula"], TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              SqrtBox[
               FractionBox["2", "3"]], "sin", 
              RowBox[{"(", 
               OverscriptBox["\[CurlyTheta]", "~"], ")"}], "+", 
              SqrtBox["2"], "cos", 
              RowBox[{"(", 
               OverscriptBox["\[CurlyTheta]", "~"], ")"}]}], "DisplayFormula"],
             TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              SqrtBox[
               FractionBox["2", "3"]], "sin", 
              RowBox[{"(", 
               OverscriptBox["\[Theta]", "~"], ")"}], "+", 
              SqrtBox["2"], "cos", 
              RowBox[{"(", 
               OverscriptBox["\[Theta]", "~"], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]}
       }], TraditionalForm]]], ")"}], "  ", "where", "  ", Cell[BoxData[
    FormBox[GridBox[{
       {Cell[TextData[Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            OverscriptBox["\[CurlyTheta]", "~"], "\[LongEqual]", 
            RowBox[{"(", 
             RowBox[{"\[Theta]", "-", "6"}], ")"}], "mod", 
            FractionBox["\[Pi]", "3"]}], "DisplayFormula"], 
          TraditionalForm]]]]]},
       {Cell[TextData[Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            OverscriptBox["\[Theta]", "~"], "\[LongEqual]", "\[Theta]", "mod", 
            FractionBox["\[Pi]", "3"]}], "DisplayFormula"], 
          TraditionalForm]]]]]}
      },
      GridBoxAlignment->{
       "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, 
        "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]]]}], 
  TraditionalForm]], "NumberedEquation",
 TaggingRules:>{"Tex Macro Name" -> "matrix"},
 CellTags->"eq:L"],

Cell[TextData[{
 "It is convenient to produce a transformation which will result in axes of \
known length. Because the rotation cannot include a translation, we desire a \
transformation matrix which will result in the ranges ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", "1"}], TraditionalForm]], "InlineFormula"],
 ", \[Hyphen]",
 Cell[BoxData[
  FormBox[
   RowBox[{
    FractionBox["1", "2"], ":", 
    FractionBox["1", "2"]}], TraditionalForm]], "InlineFormula"],
 ", and \[Hyphen]",
 Cell[BoxData[
  FormBox[
   RowBox[{
    FractionBox["1", "2"], ":", 
    FractionBox["1", "2"]}], TraditionalForm]], "InlineFormula"],
 ". Such a transformation is easily obtained by multiplying the rotation \
matrix by a diagonal matrix with the reciprocal of the maximums found above \
placed along the diagonal. This will scale each axis to a unit length. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["The normalized \[CloseCurlyQuote]rotation\[CloseCurlyQuote] matrix is \
given by: ", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"(", "\[Theta]", ")"}], TraditionalForm]], "InlineFormula"],
      " "
     }],
      CellTags->"eq:NormRxyz3"], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", "\[Theta]", "]"}], "\[CircleTimes]", 
         SubscriptBox[
          StyleBox["R", "TI"], 
          StyleBox[
           RowBox[{"x", "y", "z"}], "TI"]], 
         RowBox[{"(", "\[Theta]", ")"}]}], TraditionalForm]], "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"(", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[Cell[BoxData["1"], "InlineFormula"]]]},
              {Cell[TextData[Cell[BoxData["1"], "InlineFormula"]]]},
              {Cell[TextData[Cell[BoxData["1"], "InlineFormula"]]]}
             },
             
             GridBoxAlignment->{
              "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, 
               "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
            TraditionalForm]]], ")"}], "\[CircleTimes]", 
         SubscriptBox[
          StyleBox["R", "TI"], 
          StyleBox[
           RowBox[{"x", "y", "z"}], "TI"]], 
         RowBox[{"(", "\[Theta]", ")"}]}], TraditionalForm]], "InlineFormula"],
      " "
     }]]}
   },
   GridBoxAlignment->{
    "Columns" -> {Center, {Left}}, "ColumnsIndexed" -> {}, 
     "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"},
 CellChangeTimes->{{3.633120694586831*^9, 3.633120694586866*^9}}],

Cell["\<\
This matrix is no longer technically a rotation matrix as its inverse is no \
longer equal to its transpose. It now equal to: \
\>", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[
  RowBox[{
   RowBox[{"(", "\[Theta]", ")"}], "\[LongEqual]", 
   RowBox[{
    SubscriptBox[
     StyleBox["R", "TI"], 
     StyleBox[
      RowBox[{"x", "y", "z"}], "TI"]], 
    RowBox[{
     SuperscriptBox[
      RowBox[{"(", "\[Theta]", ")"}], 
      StyleBox["T", "TI"]], "\[CircleTimes]", 
     RowBox[{"(", Cell[BoxData[
       FormBox[GridBox[{
          {Cell[TextData[Cell[BoxData[
            FormBox[
             StyleBox[
              FractionBox["1", 
               SqrtBox["3"]], "DisplayFormula"], TraditionalForm]]]]], Cell[
           TextData[Cell[BoxData[
            FormBox[
             StyleBox[
              FractionBox["1", 
               RowBox[{
                SubscriptBox[
                 StyleBox["L", "TI"], "2"], "(", "\[Theta]", ")"}]], 
              "DisplayFormula"], TraditionalForm]]]]], Cell[TextData[Cell[
           BoxData[
            FormBox[
             StyleBox[
              FractionBox["1", 
               RowBox[{
                SubscriptBox[
                 StyleBox["L", "TI"], "3"], "(", "\[Theta]", ")"}]], 
              "DisplayFormula"], TraditionalForm]]]]]}
         },
         GridBoxAlignment->{
          "Columns" -> {Center, Center, {Center}}, "ColumnsIndexed" -> {}, 
           "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]]], 
      ")"}]}]}]}], TraditionalForm]], "NumberedEquation",
 TaggingRules:>{"Tex Macro Name" -> "matrix"},
 CellChangeTimes->{3.633120685243784*^9},
 CellTags->"eq:NormRxyz3Inverse"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Representing the Rotation ", "Subsection",
 CellChangeTimes->{3.6331129183473682`*^9}],

Cell[TextData[{
 "The final piece of the metaphorical jigsaw is to add the capability to deal \
with the machine handling of the numerics. The transforms as defined above \
assume the capacity to represent the resulting numbers. Unfortunately, on a \
device, the numerics are not handled in such a pure way and \[LongDash] \
whilst we are uninterested in the information overflow outside the \
destination representation \[LongDash] this can cause instabilities in a \
practical implementation. In the development of the algorithm, it is \
therefore necessary to define these bounds. In the unit space, these bounds \
have already been defined by Equation\[NonBreakingSpace]",
 
 CounterBox["Section", "eq:L"],
 " ; so long as the axis length can be represented on the device between \
these bounds, then overflow and underflow can be dealt with using a simple \
conditional statement. "
}], "Text"],

Cell["\<\
It is significantly advantageous to perform calculations using integer types, \
particularly given that the input and output types are integers with small \
ranges, meaning it\[CloseCurlyQuote]s possible to construct algorithms which \
avoid conversion to floating point operations. To this end, we wish to \
determine the most efficient internal representation for the transformation. \
\
\>", "Text"],

Cell[CellGroupData[{

Cell["Principles of Optimization ", "Subsubsection",
 CellChangeTimes->{3.633112931651589*^9}],

Cell["\<\
During the color space conversion, the pixel values are represented in three \
different ways: input, working and output representations. At each stage, we \
are concerned with preserving the information from the previous stage \
required by the next. For this reason, we have defined terms for the \
mathematical analysis of the problem, as well as terms for the algorithm \
development. The terms associated with each stage are as follows: \
\>", "Text"],

Cell[TextData[Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[" Data Types  "], Cell[" Src Pixel Values  "], Cell[
       " Trans Pixel Values  "], Cell[" Dst Pixel Values  "]},
      {Cell[" What?  "], Cell[" Input  "], Cell[" Working  "], Cell[
       " Output  "]},
      {Cell[" Where?  "], Cell[" Initial  "], Cell[" After Rotation  "], Cell[
       " After Re\[Hyphen]Distribution  "]},
      {Cell[" Unit Range Value  "], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]]},
      {Cell[" 1\[Hyphen]1 Int Range Value  "], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]]},
      {Cell[" 1\[Hyphen]1 Max  "], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]]},
      {Cell[" 1\[Hyphen]1 Min  "], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]]},
      {Cell[" 1\[Hyphen]1 Range  "], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]], Cell[TextData[{
        " ",
        Cell["\[Null]", "InlineFormula"],
        "  "
       }]]}
     }], TraditionalForm]]], TraditionalForm]], "InlineFormula"]], "Text"],

Cell["\<\
The rotation operation consists of 9 multiplications and 6 additions and \
constitutes the majority of the computational cost. It is this operation \
which we will focus our optimization efforts upon. The redistribution \
transformation, which comes after the rotation, processes each pixel channel \
value separately. This allows us to pull apart the rotation matrix by scaling \
each row arbitrarily, handing the knowledge of the scaling to the \
distribution. The goal of this section is to represent the matrix \
multiplication in such a way that we avoid floating\[Hyphen]point operations. \
\>", "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   RowBox[{"[", "\[Theta]", "]"}], "\[LongEqual]", 
   RowBox[{"(", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[Cell[BoxData[
          FormBox[
           StyleBox["-", "DisplayFormula"], TraditionalForm]]]]]},
        {Cell[TextData[Cell[BoxData[
          FormBox[
           StyleBox["Scale", "DisplayFormula"], TraditionalForm]]]]]},
        {Cell[TextData[Cell[BoxData[
          FormBox[
           StyleBox["-", "DisplayFormula"], TraditionalForm]]]]]}
       },
       GridBoxAlignment->{
        "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, 
         "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]]], 
    ")"}], "\[CircleTimes]", 
   RowBox[{"[", "\[Theta]", "]"}], " ", "where", "  ", 
   RowBox[{
    RowBox[{"[", "\[Theta]", "]"}], "\[Element]", 
    StyleBox["Z",
     FontSlant->"Plain"]}]}], TraditionalForm]], "NumberedEquation",
 CellTags->"eq:NormRxyz4"],

Cell[TextData[{
 "Given an infinite set of integers, this is not a problem. However, we wish \
to choose ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " to lie in a finite range, which depends on the color depth of the source. \
Ideally, we\[CloseCurlyQuote]d like the result of the rotation to have a bit \
depth not greater than twice the bit depth of the source, i.e. for \
8\[Hyphen]bit pixel values, we would like the rotated LCaCb values to be \
expressible as 16\[Hyphen]bit integers. To accommodate 3 multiplications and \
2 additions, the matrix ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " needs to be represented in two fewer bits than the source. "
}], "Text"],

Cell[TextData[{
 "This unit range is discretized into steps of ",
 Cell[BoxData[
  FormBox[
   FractionBox["1"], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   FractionBox["1"], TraditionalForm]], "InlineFormula"],
 ". The question then is to what degree of accuracy do we need to represent \
the internal numerics? If we represent the transformation in a discrete type ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ", we can express the problem in terms of the largest perturbation which can \
be made to the transformation without affecting the result. "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox["\[CenterDot]", "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox["\[LongEqual]", "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"let", "  "}], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "+"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]]},
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            RowBox[{"(", "+", ")"}], "\[CenterDot]"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "+"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], "\[Null]", "\[Null]"},
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            RowBox[{"therefore", " ", "if", " "}], "\[CenterDot]"}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox["\[LongEqual]", "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"then", "  ", "\[CenterDot]", "\[LongEqual]"}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]], "\[Null]"}
     },
     GridBoxAlignment->{
      "Columns" -> {Center, Left, Left, {Left}}, "ColumnsIndexed" -> {}, 
       "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]]], 
  TraditionalForm]], "NumberedEquation",
 CellTags->"eq:lxyPixel"],

Cell[TextData[{
 "The continuous rotation ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " can be expressed as the sum of its discrete representation ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " with a discretization factor ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " and the correction ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". The elements of the discrete rotation can be expressed as rational \
fractions. "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          FractionBox[
           RowBox[{"\[LongEqual]", 
            StyleBox["i", "TI"], 
            StyleBox["n", "TI"], 
            StyleBox["t", "TI"], 
            RowBox[{"(", "\[CenterDot]", ")"}]}], 
           RowBox[{"  ", 
            RowBox[{
             RowBox[{
              RowBox[{
               StyleBox["w", "TI"], 
               StyleBox["h", "TI"], 
               StyleBox["e", "TI"], 
               StyleBox["r", "TI"], 
               StyleBox["e", "TI"], "  ", 
               StyleBox["i", "TI"], 
               StyleBox["n", "TI"], 
               StyleBox["t", "TI"], 
               RowBox[{"(", "1.5", ")"}]}], "\[LongEqual]", "1"}], ",", 
             RowBox[{
              RowBox[{
               StyleBox["i", "TI"], 
               StyleBox["n", "TI"], 
               StyleBox["t", "TI"], 
               RowBox[{"(", 
                RowBox[{"-", "1.5"}], ")"}]}], "\[LongEqual]", 
              RowBox[{"-", "1"}]}]}]}]], "DisplayFormula"], 
         TraditionalForm]]]],
        CellTags->"eq:dRRange"]},
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          FractionBox[
           FractionBox[
            RowBox[{
             StyleBox["t", "TI"], 
             StyleBox["h", "TI"], 
             StyleBox["e", "TI"], 
             StyleBox["r", "TI"], 
             StyleBox["e", "TI"], 
             StyleBox["f", "TI"], 
             StyleBox["o", "TI"], 
             StyleBox["r", "TI"], 
             StyleBox["e", "TI"], "  ", "-", "1"}], 
            RowBox[{"<", "<", "1"}]], "\[Null]"], "DisplayFormula"], 
         TraditionalForm]]]]]}
     },
     GridBoxAlignment->{
      "Columns" -> {{Right}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
       "RowsIndexed" -> {}}], TraditionalForm]]], 
  TraditionalForm]], "NumberedEquation"],

Cell[TextData[{
 "It should be noted that \[LongDash] unlike the source type \[LongDash] the \
perturbation can be negative. The definition of the function ",
 Cell[BoxData[
  FormBox[
   StyleBox[
    RowBox[{"i", "n", "t"}], "TI"], TraditionalForm]], "InlineFormula"],
 " results in the sign of the perturbation matching the sign of the \
discretized transformation matrix. We must therefore consider both the \
maximum and minimum of ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". As ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", "\[LessEqual]", "\[LessEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 " the extrema of ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " are found where ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " is a vector with elements of 0 and 1. If the matrix is decomposed into a \
sum of positive and negative elements ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[LongEqual]", "+"], 
    SubscriptBox["+", "-"]}], TraditionalForm]], "InlineFormula"],
 " then the extrema are given by ",
 Cell[BoxData[
  FormBox[
   RowBox[{"max", "(", 
    RowBox[{
     SubscriptBox["\[Null]", "+"], "\[CenterDot]", 
     StyleBox["1",
      FontSlant->"Bold"]}], ")"}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"min", "(", 
    RowBox[{
     SubscriptBox["\[Null]", "-"], "\[CenterDot]", 
     StyleBox["1",
      FontSlant->"Bold"]}], ")"}], TraditionalForm]], "InlineFormula"],
 ". Where the elements are positive or negative is determined by the sign of \
the elements in the rotation matrix ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ".  "
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Factoring the Rotation ", "Subsubsection",
 CellChangeTimes->{3.633112944488859*^9}],

Cell[TextData[{
 "If we were to scale the entire matrix evenly, the top row would dominate as \
it is always positive, and the necessary discrete representation would be \
characterised by ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[LongEqual]", 
    RowBox[{"3", " "}]}], TraditionalForm]], "InlineFormula"],
 ". This would, however, necessitate the matrix being stored in a data type \
with at least 2 more bits than the source type. "
}], "Text"],

Cell[TextData[{
 "The second and third rows each sum to zero (",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[CenterDot]", 
    StyleBox["1",
     FontSlant->"Bold"], "\[LongEqual]", 
    RowBox[{"[", 
     RowBox[{
      SqrtBox["3"], ",", "0", ",", "0"}], "]"}]}], TraditionalForm]], 
  "InlineFormula"],
 ", where ",
 Cell[BoxData[
  FormBox[
   StyleBox["1",
    FontSlant->"Bold"], TraditionalForm]], "InlineFormula"],
 " is a vector of ones), allowing us to state that each of the rows has one \
element of the opposite sign to the other two elements. The discretization \
for the second and third rows then only requires ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[LongEqual]", 
    RowBox[{"2", " "}]}], TraditionalForm]], "InlineFormula"],
 ". It is also possible to pull out common factors from the rows, resulting \
in all elements taking values between \[Hyphen]1 and 1. "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   RowBox[{"(", "\[Theta]", ")"}], "\[LongEqual]", 
   RowBox[{"(", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[Cell[BoxData[
          FormBox[
           StyleBox[
            FractionBox["1", 
             SqrtBox["3"]], "DisplayFormula"], TraditionalForm]]]]]},
        {Cell[TextData[Cell[BoxData[
          FormBox[
           StyleBox[
            SqrtBox[
             FractionBox["2", "3"]], "DisplayFormula"], 
           TraditionalForm]]]]]},
        {Cell[TextData[Cell[BoxData[
          FormBox[
           StyleBox[
            SqrtBox[
             FractionBox["2", "3"]], "DisplayFormula"], TraditionalForm]]]]]}
       },
       GridBoxAlignment->{
        "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, 
         "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]]], 
    ")"}], "\[CircleTimes]", 
   RowBox[{"(", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox["1", "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox["1", "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox["1", "DisplayFormula"], TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"-", "sin", 
              RowBox[{"(", 
               RowBox[{"\[Theta]", "+", "6"}], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"cos", "(", "\[Theta]", ")"}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"sin", "(", 
              RowBox[{"\[Theta]", "-", "6"}], ")"}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"-", "cos", 
              RowBox[{"(", 
               RowBox[{"\[Theta]", "+", "6"}], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"-", "sin", 
              RowBox[{"(", "\[Theta]", ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"cos", "(", 
              RowBox[{"\[Theta]", "-", "6"}], ")"}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]}
       },
       GridBoxAlignment->{
        "Columns" -> {Center, Left, {Left}}, "ColumnsIndexed" -> {}, 
         "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]]], 
    ")"}]}], TraditionalForm]], "NumberedEquation",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["\<\
To facilitate the quantization, we next factor the second and third rows such \
that the largest element of each row equals exactly 1. As previously \
mentioned, the largest element has the opposite sign to the other two \
elements in a given row. So, the steps required to perform the factorization \
are as follows: \
\>", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[CellGroupData[{

Cell["Find the sign of each of the elements. ", "Item",
 TaggingRules:>{"Tex Macro Name" -> "itemize"}],

Cell["Determine which of those elements is of the opposite sign. ", "Item",
 TaggingRules:>{"Tex Macro Name" -> "itemize"}],

Cell["Factor each row by that largest element. ", "Item",
 TaggingRules:>{"Tex Macro Name" -> "itemize"}]
}, Open  ]],

Cell["\<\
The sign of the elements is most easily seen by looking at the rotation as \
phase shifted sine functions. \
\>", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   RowBox[{"[", "\[Theta]", "]"}], "\[LongEqual]", 
   RowBox[{"(", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox["1", "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox["1", "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox["1", "DisplayFormula"], TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"\[Theta]", "-", 
              FractionBox[
               RowBox[{"5", "\[Pi]"}], "6"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"\[Theta]", "+", 
              FractionBox[
               RowBox[{"3", "\[Pi]"}], "6"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"\[Theta]", "-", "6"}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"\[Theta]", "-", 
              FractionBox[
               RowBox[{"2", "\[Pi]"}], "6"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"\[Theta]", "-", 
              FractionBox[
               RowBox[{"6", "\[Pi]"}], "6"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"\[Theta]", "+", 
              FractionBox[
               RowBox[{"2", "\[Pi]"}], "6"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]}
       },
       GridBoxAlignment->{
        "Columns" -> {Center, Left, {Left}}, "ColumnsIndexed" -> {}, 
         "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]]], 
    ")"}]}], TraditionalForm]], "NumberedEquation",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["So the signs look like  ", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "Each row is a series of three sin waves each ",
 Cell[BoxData[
  FormBox[
   FractionBox[
    RowBox[{"2", "\[Pi]"}], "3"], TraditionalForm]], "InlineFormula"],
 " out of phase with each other. The rows are",
 Cell[BoxData[
  FormBox[
   FractionBox["\[Pi]", "2"], TraditionalForm]], "InlineFormula"],
 " out of phase with each other. The largest element changes every ",
 Cell[BoxData[
  FormBox[
   FractionBox["\[Pi]", "6"], TraditionalForm]], "InlineFormula"],
 " radians repeating every ",
 Cell[BoxData[
  FormBox["\[Pi]", TraditionalForm]], "InlineFormula"],
 " radians. "
}], "Text"],

Cell[TextData[{
 "By defining ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " as ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Theta]", "\[LongEqual]", "\[CapitalTheta]", "+"}], 
   TraditionalForm]], "InlineFormula"],
 " \[LongDash] where ",
 Cell[BoxData[
  FormBox[
   RowBox[{
   "\[LongEqual]", "\[Theta]", "\[NegativeThinSpace]", "\[NegativeThinSpace]  ",
     "mod", "6"}], TraditionalForm]], "InlineFormula"],
 ", and ",
 Cell[BoxData[
  FormBox["\[CapitalTheta]", TraditionalForm]], "InlineFormula"],
 " is the starting value for the region in which ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " lies \[LongDash] and substituting in the function ",
 Cell[BoxData[
  FormBox[
   RowBox[{"[", "\[Phi]", "]"}], TraditionalForm]], "InlineFormula"],
 ": "
}], "Text"],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", "\[Phi]", "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }],
      CellTags->"eq:fReDef"], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         FractionBox["1", "2"], 
         RowBox[{"(", 
          RowBox[{"1", "+", 
           SqrtBox["3"], "tan", 
           RowBox[{"(", "\[Phi]", ")"}]}], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]]],

Cell["we can now rewrite the factored rotation as shown in ", "Text"],

Cell[TextData[{
 "We can now relate the functions to each other, since they are now \
essentially the same function, and ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " has the same domain; the values they take have the same range, despite \
being in different positions in the matrix. This allows us to write the \
piecewise function ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " independently as a function ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ", which re\[Hyphen]orders the elements of the matrix in region ",
 Cell[BoxData[
  FormBox[
   StyleBox["A",
    FontSlant->"Bold"], TraditionalForm]], "InlineFormula"],
 " appropriately for the other regions. "
}], "Text"],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", "\[Theta]", "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }],
      CellTags->"eq:factoredMatrixDef"], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", 
          RowBox[{",", "\[Theta]"}], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", 
          RowBox[{
           RowBox[{"(", Cell[BoxData[
             FormBox[GridBox[{
                {Cell[TextData[{
                  " ",
                  Cell["1", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["1", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["1", "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell[BoxData[{"fRe", "\n", 
                   RowBox[{"(", ")"}]}], "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["1", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell[BoxData[{"fRe", "\n", "(", "\n", "-", "\n", 
                  ")"}], "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell[BoxData[{"fRe", "\n", "(", "\n", 
                   RowBox[{
                    FractionBox[
                    StyleBox["\[Pi]", "uniA"], "6"], "-"}], "\n", 
                  ")"}], "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell[BoxData[{"fRe", "\n", "(", "\n", 
                   RowBox[{"-", 
                    FractionBox[
                    StyleBox["\[Pi]", "uniA"], "6"]}], "\n", 
                  ")"}], "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["1", "InlineFormula"],
                  " "
                 }]]}
               }], TraditionalForm]]], ")"}], ",", "\[Theta]"}], "]"}]}], 
        TraditionalForm]], "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "The scaling factor ",
 Cell[BoxData[
  FormBox[
   RowBox[{"(", ")"}], TraditionalForm]], "InlineFormula"],
 " can also be further simplified by separating the sign and combining the \
functional parts.  ",
 Cell[BoxData[
  FormBox[GridBox[{
     {Cell[TextData[{
       " ",
       Cell[BoxData[
        FormBox[
         RowBox[{"(", "\[Theta]", ")"}], TraditionalForm]], "InlineFormula"],
       " "
      }]], Cell[TextData[Cell[BoxData[
       FormBox[Cell[BoxData[
         FormBox[GridBox[{
            {Cell[TextData[{
              " ",
              Cell[BoxData[
               RowBox[{"\n", Cell[BoxData[
                 FormBox[
                 Cell[TextData[Cell["1", "InlineFormula"]]], 
                  TraditionalForm]]]}]], "InlineFormula"],
              " "
             }]], Cell[" "]}
           }], TraditionalForm]]], TraditionalForm]], "InlineFormula"]]]},
     {Cell[TextData[{
       " ",
       Cell[BoxData[
        FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
       " "
      }]], Cell[TextData[{
       " ",
       Cell[BoxData[
        FormBox[
         RowBox[{"\[LongEqual]", 
          RowBox[{"(", Cell[BoxData[
            FormBox[Cell[""], TraditionalForm]]], ")"}], "  ", "where", "  ", 
          Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[Cell[BoxData[{
                OverscriptBox["\[Theta]", "~"], "\n", "\[LongEqual]", "\n", 
               "\[Theta]", "\n", "mod", "\n", 
                FractionBox["\[Pi]", "3"]}], "InlineFormula"]]]},
              {Cell[TextData[Cell[BoxData[{
                OverscriptBox["\[CurlyTheta]", "~"], "\n", "\[LongEqual]", 
               "\n", 
                RowBox[{"(", 
                 RowBox[{"\[Theta]", "-", "6"}], ")"}], "\n", "mod", "\n", 
                FractionBox["\[Pi]", "3"]}], "InlineFormula"]]]}
             },
             
             GridBoxAlignment->{
              "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, 
               "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
            TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
       " "
      }]]}
    }], TraditionalForm]]],
 " "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"},
 CellChangeTimes->{{3.63312071660774*^9, 3.6331208331016703`*^9}}],

Cell[TextData[{
 "then ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", "\[Theta]", ")"}], "\[LongEqual]", 
    RowBox[{"(", "\[Theta]", ")"}], "\[CircleTimes]", 
    RowBox[{"(", "\[Theta]", ")"}]}], TraditionalForm]], "InlineFormula"],
 ", where ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " is a piecewise function containing the signs.  "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", "\[Theta]", "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", "\[Theta]", "]"}], "+", 
         RowBox[{"[", "\[Theta]", "]"}]}], TraditionalForm]], "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", "\[Theta]", "]"}], "\[CircleTimes]", "\[CircleTimes]", 
         RowBox[{"(", "\[Theta]", ")"}], "\[CircleTimes]", 
         RowBox[{"[", 
          StyleBox["n", "TI"], "]"}], "\[CircleTimes]", 
         RowBox[{"[", "\[Theta]", "]"}], "\[CircleTimes]", 
         RowBox[{"[", 
          RowBox[{
           RowBox[{"[", 
            RowBox[{"\[Theta]", ",", 
             StyleBox["n", "TI"]}], "]"}], "+", 
           RowBox[{"[", 
            RowBox[{"\[Theta]", ",", 
             StyleBox["n", "TI"]}], "]"}]}], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"(", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox["1", 3]], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox["1", 2]], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox["1", 2]], "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], ")"}], "\[CircleTimes]", 
         RowBox[{"(", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell["1", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData["2"], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData["2"], "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], ")"}], "\[CircleTimes]", 
         RowBox[{"(", "\[Theta]", ")"}], "\[CircleTimes]", 
         RowBox[{"[", 
          RowBox[{
           RowBox[{"[", 
            RowBox[{"\[Theta]", ",", 
             StyleBox["n", "TI"]}], "]"}], "+", 
           RowBox[{"[", 
            RowBox[{"\[Theta]", ",", 
             StyleBox["n", "TI"]}], "]"}]}], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["defining ", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", 
         RowBox[{"\[Theta]", ",", 
          StyleBox["n", "TI"]}], "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }],
      CellTags->"eq:scaleDef"], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"(", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox["1", 3]], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData["2"], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData["2"], "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], ")"}], "\[CircleTimes]", 
         RowBox[{"(", "\[Theta]", ")"}]}], TraditionalForm]], "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", "\[Theta]", "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", "\[Theta]", "]"}], "\[CircleTimes]", 
         RowBox[{"[", 
          RowBox[{"[", 
           RowBox[{"\[Theta]", ",", 
            StyleBox["n", "TI"]}], "]"}], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", "\[Theta]", "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", "\[Theta]", "]"}], "\[CircleTimes]", 
         RowBox[{"[", 
          RowBox[{"[", 
           RowBox[{"\[Theta]", ",", 
            StyleBox["n", "TI"]}], "]"}], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "the perturbation to the rotated channel elements ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " is found for an input set of pixel values ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[LongEqual]", 
    SuperscriptBox["2", 
     StyleBox["n", "TI"]]}], TraditionalForm]], "InlineFormula"],
 " "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["+", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", "\[Theta]", "]"}], "\[CenterDot]", "+", 
         RowBox[{"[", "\[Theta]", "]"}], "\[CenterDot]"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         SuperscriptBox["2", 
          StyleBox["n", "TI"]], 
         RowBox[{"[", "\[Theta]", "]"}], "\[CenterDot]"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         SuperscriptBox["2", 
          StyleBox["n", "TI"]], 
         RowBox[{"[", "\[Theta]", "]"}], "\[CircleTimes]", 
         RowBox[{"[", 
          RowBox[{"[", 
           RowBox[{"\[Theta]", ",", 
            StyleBox["n", "TI"]}], "]"}], "]"}], "\[CenterDot]"}], 
        TraditionalForm]], "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", 
          RowBox[{
           RowBox[{"(", Cell[BoxData[
             FormBox[GridBox[{
                {Cell[TextData[{
                  " ",
                  Cell["0", "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell[BoxData[{"2", "\n", 
                   RowBox[{"[", "]"}]}], "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell[BoxData[{"2", "\n", 
                   RowBox[{"[", 
                    RowBox[{"6", "-"}], "]"}]}], "InlineFormula"],
                  " "
                 }]]}
               }], TraditionalForm]]], ")"}], "\[CircleTimes]", 
           RowBox[{"(", Cell[BoxData[
             FormBox[GridBox[{
                {Cell[TextData[{
                  " ",
                  Cell["0", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["0", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["0", "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell["1", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["0", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["-1", "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell["1", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["-1", "InlineFormula"],
                  " "
                 }]], Cell[TextData[{
                  " ",
                  Cell["0", "InlineFormula"],
                  " "
                 }]]}
               }], TraditionalForm]]], ")"}], ",", "\[Theta]"}], "]"}]}], 
        TraditionalForm]], "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "So, to minimize the perturbation, we need to simultaneously minimize ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[PlusMinus]", "2", 
    RowBox[{"[", "]"}]}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[PlusMinus]", "2", 
    RowBox[{"[", 
     RowBox[{"6", "-"}], "]"}]}], TraditionalForm]], "InlineFormula"],
 " "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "caption Perturbation to channels a and b against angle ",
 Cell[BoxData[
  FormBox["\[Delta]\[Theta]", TraditionalForm]], "InlineFormula"],
 " \nFor n \[LongEqual] 8 with ",
 Cell[BoxData[
  FormBox["\[Iota]", TraditionalForm]], "InlineFormula"],
 " regions shaded and extrema labelled  "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "The maxima for each function are where ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[PlusMinus]", "2", 
    RowBox[{"[", "]"}], "\[LongEqual]", "\[PlusMinus]", "1"}], 
   TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[PlusMinus]", "2", 
    RowBox[{"[", 
     RowBox[{"6", "-"}], "]"}], "\[LongEqual]", "\[PlusMinus]", "1"}], 
   TraditionalForm]], "InlineFormula"],
 ", and the minima are where ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[PlusMinus]", "2", 
    RowBox[{"[", "]"}], "\[LongEqual]", "0"}], TraditionalForm]], 
  "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[PlusMinus]", "2", 
    RowBox[{"[", 
     RowBox[{"6", "-"}], "]"}], "\[LongEqual]", "0"}], TraditionalForm]], 
  "InlineFormula"],
 ". To find the corresponding values of ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ", all that is needed is an inverse function for ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". In essence ",
 Cell[BoxData[
  FormBox[
   RowBox[{"[", "\[Phi]", "]"}], TraditionalForm]], "InlineFormula"],
 " discretizes ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SqrtBox["3"], "tan", 
    RowBox[{"(", "\[Phi]", ")"}]}], TraditionalForm]], "InlineFormula"],
 " into steps of ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["2", 
    RowBox[{"3", "-", 
     StyleBox["n", "TI"]}]], TraditionalForm]], "InlineFormula"],
 ". The minima can be found by taking the inverse of ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SqrtBox["3"], "tan", 
    RowBox[{"(", "\[Phi]", ")"}]}], TraditionalForm]], "InlineFormula"],
 ", given that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", "\[LessEqual]", 
    SqrtBox["3"], "tan", 
    RowBox[{"(", "\[Phi]", ")"}], "\[LessEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 " for ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", "\[LessEqual]", "\[Phi]", "\[LessEqual]", "6"}], 
   TraditionalForm]], "InlineFormula"],
 " we can say that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"Round", 
    RowBox[{"[", 
     RowBox[{
      SuperscriptBox["2", 
       RowBox[{
        StyleBox["n", "TI"], "-", "3"}]], 
      SqrtBox["3"], "tan", 
      RowBox[{"(", "\[Phi]", ")"}]}], "]"}], "\[Element]", 
    RowBox[{"{", 
     RowBox[{"0", ",", "1", ",", "2", ",", "\[CenterEllipsis]", 
      SuperscriptBox["2", 
       RowBox[{
        StyleBox["n", "TI"], "-", "3"}]]}], "}"}]}], TraditionalForm]], 
  "InlineFormula"],
 " "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", "\[Phi]", "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "0"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", 
         RowBox[{"6", "-", "\[Phi]"}], "]"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"0", "  "}], "when"}], TraditionalForm]], "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         SuperscriptBox["2", 
          RowBox[{
           StyleBox["n", "TI"], "-", "3"}]], 
         SqrtBox["3"], "tan", 
         RowBox[{"(", "\[Phi]", ")"}]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         StyleBox["m", "TI"]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         SuperscriptBox["2", 
          RowBox[{
           StyleBox["n", "TI"], "-", "3"}]], 
         SqrtBox["3"], "tan", 
         RowBox[{"(", 
          RowBox[{"6", "-", "\[Phi]"}], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         StyleBox["m", "TI"], "  ", "where", "  ", 
         StyleBox["m", "TI"], "\[LongEqual]", "0", ",", "1", ",", "2", 
         "\[CenterEllipsis]", 
         SuperscriptBox["2", 
          RowBox[{
           StyleBox["n", "TI"], "-", "3"}]]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         StyleBox["b", "TI"], "\[LongEqual]"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"arctan", "(", 
         FractionBox[
          RowBox[{
           StyleBox["m", "TI"], 
           SuperscriptBox["2", 
            RowBox[{"3", "-", 
             StyleBox["n", "TI"]}]]}], 
          SqrtBox["3"]], ")"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         StyleBox["a", "TI"], "\[LongEqual]"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"arctan", "(", 
         FractionBox[
          RowBox[{"2", 
           SqrtBox["3"], 
           StyleBox["m", "TI"]}], 
          RowBox[{
           SuperscriptBox["2", 
            StyleBox["n", "TI"]], "-", "2", 
           StyleBox["m", "TI"]}]], ")"}], TraditionalForm]], "InlineFormula"],
      
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell["\<\
The maxima can be found by recognizing that the maximum rounding error is a \
half and evaluating at these points \
\>", "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", 
         StyleBox["b", "TI"], "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "\[PlusMinus]", "1"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"[", 
         RowBox[{"6", "-", 
          StyleBox["a", "TI"]}], "]"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "\[PlusMinus]", 
         RowBox[{"1", "  "}], "when"}], TraditionalForm]], "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        StyleBox["b", "TI"], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "arctan", 
         RowBox[{"(", 
          RowBox[{
           FractionBox[
            SuperscriptBox["2", 
             RowBox[{"3", "-", 
              StyleBox["n", "TI"]}]], 
            SqrtBox["3"]], "(", 
           RowBox[{
            StyleBox["m", "TI"], "+", 
            FractionBox["1", "2"]}], ")"}], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        StyleBox["a", "TI"], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "arctan", 
         RowBox[{"(", 
          FractionBox[
           RowBox[{"2", 
            SqrtBox["3"], 
            RowBox[{"(", 
             RowBox[{
              StyleBox["m", "TI"], "+", 
              FractionBox["1", "2"]}], ")"}]}], 
           RowBox[{
            SuperscriptBox["2", 
             StyleBox["n", "TI"]], "-", "2", 
            RowBox[{"(", 
             RowBox[{
              StyleBox["m", "TI"], "+", 
              FractionBox["1", "2"]}], ")"}]}]], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        StyleBox["b", "TI"], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "arctan", 
         RowBox[{"(", 
          FractionBox[
           RowBox[{
            RowBox[{"(", 
             RowBox[{"2", 
              StyleBox["m", "TI"], "+", "1"}], ")"}], 
            SuperscriptBox["2", 
             RowBox[{"2", "-", 
              StyleBox["n", "TI"]}]]}], 
           SqrtBox["3"]], ")"}]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        StyleBox["a", "TI"], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "arctan", 
         RowBox[{"(", 
          FractionBox[
           RowBox[{
            SqrtBox["3"], "(", 
            RowBox[{"2", 
             StyleBox["m", "TI"], "+", "1"}], ")"}], 
           RowBox[{
            SuperscriptBox["2", 
             StyleBox["n", "TI"]], "-", "2", 
            StyleBox["m", "TI"], "-", "1"}]], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["  ", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"with", "  ", 
         StyleBox["m", "TI"], "\[LongEqual]", "0", ",", "1", ",", "2", ",", 
         "3", "\[CenterEllipsis]", 
         SuperscriptBox["2", 
          RowBox[{
           StyleBox["n", "TI"], "-", "3"}]], "-", "1"}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], "\[Null]", "\[Null]"}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "We are interested in a compromise between the perturbations to each channel \
which is where the perturbations intersect. It would be useful to be able to \
assign a relative importance ",
 Cell[BoxData[
  FormBox["\[Alpha]", TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["\[Beta]", TraditionalForm]], "InlineFormula"],
 " to each channel a and b respectively.  "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          RowBox[{
           RowBox[{"\[Beta]", " "}], 
           RowBox[{"[", "\[Phi]", "]"}], "\[LongEqual]", 
           RowBox[{"\[Alpha]", " "}], 
           RowBox[{"[", 
            RowBox[{
             FractionBox["\[Pi]", "6"], "-", "\[Phi]"}], "]"}], "  ", 
           StyleBox["when", "TB"]}], "DisplayFormula"], 
         TraditionalForm]]]]]},
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox[
                  StyleBox[
                   RowBox[{"\[Beta]", "Round", 
                    RowBox[{"[", 
                    RowBox[{
                    SuperscriptBox["2", 
                    RowBox[{
                    StyleBox["n", "TI"], "-", "3"}]], 
                    SqrtBox["3"], "tan", 
                    RowBox[{"(", "\[Phi]", ")"}]}], "]"}], "-", "\[Alpha]", 
                    "Round", 
                    RowBox[{"[", 
                    RowBox[{
                    SuperscriptBox["2", 
                    RowBox[{
                    StyleBox["n", "TI"], "-", "3"}]], 
                    SqrtBox["3"], "tan", 
                    RowBox[{"(", 
                    RowBox[{
                    FractionBox[
                    StyleBox["\[Pi]", "uniA"], "6"], "-", "\[Phi]"}], ")"}]}],
                     "]"}]}], "DisplayFormula"], TraditionalForm]]],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox[
                  StyleBox[
                   RowBox[{"\[LongEqual]", 
                    SuperscriptBox["2", 
                    RowBox[{
                    StyleBox["n", "TI"], "-", "3"}]], 
                    RowBox[{"(", 
                    RowBox[{
                    SqrtBox["3"], "\[Alpha]", "tan", 
                    RowBox[{"(", "\[Theta]", ")"}], "+", "2", "\[Beta]", 
                    "sin", 
                    RowBox[{"(", "\[Theta]", ")"}], "sec", 
                    RowBox[{"(", 
                    RowBox[{
                    FractionBox["\[Pi]", "6"], "-", "\[Theta]"}], ")"}]}], 
                    ")"}]}], "DisplayFormula"], TraditionalForm]]],
                " "
               }]]}
             },
             
             GridBoxAlignment->{
              "Columns" -> {{Right}}, "ColumnsIndexed" -> {}, 
               "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
            TraditionalForm]]], "DisplayFormula"], TraditionalForm]]]]]}
     },
     GridBoxAlignment->{
      "Columns" -> {{Right}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
       "RowsIndexed" -> {}}], TraditionalForm]]], 
  TraditionalForm]], "Equation",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[TextData[{
 "The values ",
 Cell[BoxData[
  FormBox["\[Alpha]", TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["\[Beta]", TraditionalForm]], "InlineFormula"],
 " can only move the point of intersection within the bounds of the extrema. \
Therefore, any solution for the point of intersection will enable the \
bounding extrema to be identified. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[TextData[{
 "We solve first for the case where ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Alpha]", "\[LongEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Beta]", "\[LongEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 ". Recognizing that the rounded part can only take certain values "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["i", "TI"], "\[LongEqual]", "Round", 
   RowBox[{"[", 
    RowBox[{
     SuperscriptBox["2", 
      RowBox[{
       StyleBox["n", "TI"], "-", "3"}]], 
     SqrtBox["3"], "tan", 
     RowBox[{"(", "\[Phi]", ")"}]}], "]"}], "-", "Round", 
   RowBox[{"[", 
    RowBox[{
     SuperscriptBox["2", 
      RowBox[{
       StyleBox["n", "TI"], "-", "3"}]], 
     SqrtBox["3"], "tan", 
     RowBox[{"(", 
      RowBox[{
       FractionBox["\[Pi]", "6"], "-", "\[Phi]"}], ")"}]}], "]"}], "  ", 
   "where", "  ", 
   StyleBox["i", "TI"], "\[LongEqual]", "0", ",", "1", ",", "2", 
   "\[CenterEllipsis]", 
   SuperscriptBox["2", 
    RowBox[{
     StyleBox["n", "TI"], "-", "2"}]]}], TraditionalForm]], "NumberedEquation",\

 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell["then ", "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell["", "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          RowBox[{
           StyleBox["i", "TI"], "\[LongEqual]", "arctan", 
           RowBox[{"(", 
            FractionBox[
             RowBox[{
              SqrtBox[
               RowBox[{
                SuperscriptBox[
                 StyleBox["i", "TI"], "2"], 
                SuperscriptBox["2", 
                 RowBox[{"6", "-", "2", 
                  StyleBox["n", "TI"]}]], "-", 
                StyleBox["i", "TI"], 
                SuperscriptBox["2", 
                 RowBox[{"4", "-", 
                  StyleBox["n", "TI"]}]], "+", "49"}]], "+", 
              StyleBox["i", "TI"], 
              SuperscriptBox["2", 
               RowBox[{"3", "-", 
                StyleBox["n", "TI"]}]], "-", "7"}], 
             RowBox[{"2", 
              SqrtBox["3"]}]], ")"}], "  ", "where", "  ", 
           StyleBox["i", "TI"], "\[LongEqual]", "0", ",", "1", ",", "2", 
           "\[CenterEllipsis]", 
           SuperscriptBox["2", 
            RowBox[{
             StyleBox["n", "TI"], "-", "2"}]]}], "DisplayFormula"], 
         TraditionalForm]]]]]}
     },
     GridBoxAlignment->{
      "Columns" -> {{Right}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
       "RowsIndexed" -> {}}], TraditionalForm]]], 
  TraditionalForm]], "Equation",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell["\<\
Each point of intersection is defined and bounded by 4 extrema. Comparing \
with the functional form of the extrema allows these 4 points to be \
identified. \
\>", "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell["\<\
Separating the points of intersection into even and odd terms facilitates the \
identification. \
\>", "Text"],

Cell[TextData[{
 Cell[BoxData[
  FormBox[Cell[BoxData[
    FormBox[GridBox[{
       {Cell["  "], Cell[" Channel a  "], Cell[" Channel b  "], Cell[
        " i  "]},
       {Cell[" Minima  "], Cell[TextData[{
         " ",
         Cell[BoxData[{
          StyleBox["a", "TI"], "\n", 
          RowBox[{"(", 
           FractionBox[
            StyleBox["i", "TI"], "2"], ")"}], "\n", "\[LongEqual]", "\n", 
          StyleBox["a", "TI"], "\n", 
          StyleBox["i", "TI"]}], "InlineFormula"],
         "  "
        }]], Cell[TextData[{
         " ",
         Cell[BoxData[{
          StyleBox["b", "TI"], "\n", 
          RowBox[{"(", 
           FractionBox[
            StyleBox["i", "TI"], "2"], ")"}], "\n", "\[LongEqual]", "\n", 
          StyleBox["b", "TI"], "\n", 
          StyleBox["i", "TI"]}], "InlineFormula"],
         "  "
        }]], Cell[TextData[{
         " ",
         Cell[BoxData[{
          StyleBox["i", "TI"], "\n", "\[Element]", "\n", 
          RowBox[{"{", 
           RowBox[{"0", ",", "2", ",", "4", ",", "6", "\[CenterEllipsis]", 
            SuperscriptBox["2", 
             RowBox[{
              StyleBox["n", "TI"], "-", "2"}]]}], "}"}]}], "InlineFormula"],
         " "
        }]]},
       {Cell[" Maxima  "], Cell[TextData[{
         " ",
         Cell[BoxData[{
          StyleBox["a", "TI"], "\n", 
          RowBox[{"(", 
           FractionBox[
            RowBox[{
             StyleBox["i", "TI"], "-", "1"}], "2"], ")"}], "\n", 
         "\[LongEqual]", "\n", 
          StyleBox["a", "TI"], "\n", 
          StyleBox["i", "TI"]}], "InlineFormula"],
         "  "
        }]], Cell[TextData[{
         " ",
         Cell[BoxData[{
          StyleBox["b", "TI"], "\n", 
          RowBox[{"(", 
           FractionBox[
            RowBox[{
             StyleBox["i", "TI"], "-", "1"}], "2"], ")"}], "\n", 
         "\[LongEqual]", "\n", 
          StyleBox["b", "TI"], "\n", 
          StyleBox["i", "TI"]}], "InlineFormula"],
         "  "
        }]], Cell[TextData[{
         " ",
         Cell[BoxData[{
          StyleBox["i", "TI"], "\n", "\[Element]", "\n", 
          RowBox[{"{", 
           RowBox[{"1", ",", "3", ",", "5", ",", "7", "\[CenterEllipsis]", 
            SuperscriptBox["2", 
             RowBox[{
              StyleBox["n", "TI"], "-", "2"}]], "-", "1"}], "}"}]}], 
          "InlineFormula"],
         "  "
        }]]}
      }], TraditionalForm]]], TraditionalForm]], "InlineFormula"],
 " "
}], "Text"],

Cell[TextData[{
 "The following ranges are guaranteed to be true for even or odd values of ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 ", with very specific values of ",
 Cell[BoxData[
  FormBox[
   StyleBox["p", "TI"], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   StyleBox["q", "TI"], TraditionalForm]], "InlineFormula"],
 ". "
}], "Text"],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[Cell[BoxData[
         FormBox[GridBox[{
            {Cell[TextData[Cell[BoxData[{
              StyleBox["b", "TI"], "\n", 
              RowBox[{
               StyleBox["p", "TI"], "-", "1"}]}], "InlineFormula"]]], Cell[
             TextData[Cell["<", "InlineFormula"]]]},
            {Cell[TextData[Cell[BoxData[{
              StyleBox["a", "TI"], "\n", 
              StyleBox["q", "TI"]}], "InlineFormula"]]], Cell[TextData[Cell[
             "<", "InlineFormula"]]]}
           },
           
           GridBoxAlignment->{
            "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
             "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
          TraditionalForm]]], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         StyleBox["i", "TI"], Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["a", "TI"], "\n", 
               RowBox[{
                StyleBox["q", "TI"], "+", "1"}]}], "InlineFormula"]]]},
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["b", "TI"], "\n", 
               StyleBox["p", "TI"]}], "InlineFormula"]]]}
            },
            
            GridBoxAlignment->{
             "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
              "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
           TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[Vee]", Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[Cell[BoxData[{
               StyleBox["a", "TI"], "\n", 
               RowBox[{
                StyleBox["q", "TI"], "+", "1"}]}], "InlineFormula"]]], Cell[
              TextData[Cell["<", "InlineFormula"]]]},
             {Cell[TextData[Cell[BoxData[{
               StyleBox["b", "TI"], "\n", 
               StyleBox["p", "TI"]}], "InlineFormula"]]], Cell[TextData[Cell[
              "<", "InlineFormula"]]]}
            },
            
            GridBoxAlignment->{
             "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
              "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
           TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         RowBox[{
          StyleBox["i", "TI"], "+", "1"}], Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["b", "TI"], "\n", 
               RowBox[{
                StyleBox["p", "TI"], "+", "1"}]}], "InlineFormula"]]]},
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["a", "TI"], "\n", 
               RowBox[{
                StyleBox["q", "TI"], "+", "2"}]}], "InlineFormula"]]]}
            },
            
            GridBoxAlignment->{
             "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
              "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
           TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[Cell[BoxData[
         FormBox[GridBox[{
            {Cell[TextData[Cell[BoxData[
              FormBox["p", TI]], "InlineFormula"]]], Cell[TextData[Cell[
             BoxData[{"\[Element]", "\n", 
              RowBox[{"{", 
               RowBox[{"2", 
                StyleBox["N",
                 FontSlant->"Plain"]}], "}"}]}], "InlineFormula"]]]},
            {Cell[TextData[Cell[BoxData[
              FormBox["q", TI]], "InlineFormula"]]], Cell[TextData[Cell[
             BoxData[{"\[Element]", "\n", 
              RowBox[{"{", 
               RowBox[{"2", 
                StyleBox["N",
                 FontSlant->"Plain"]}], "}"}]}], "InlineFormula"]]]},
            {Cell[TextData[Cell["2", "InlineFormula"]]], Cell[TextData[Cell[
             BoxData[{"\[LessEqual]", "\n", 
              StyleBox["i", "TI"], "\n", "\[LessEqual]", "\n", 
              SuperscriptBox["2", 
               RowBox[{
                StyleBox["n", "TI"], "-", "2"}]], "\n", "-", "\n", 
             "1"}], "InlineFormula"]]]}
           },
           
           GridBoxAlignment->{
            "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
             "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
          TraditionalForm]]], TraditionalForm]], "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]]],

Cell[TextData[{
 "This slightly glib definition illustrates the pattern for the extrema \
bounding the points of intersection. At the start of a ",
 Cell[BoxData[
  FormBox[
   FractionBox["\[CapitalPi]", "6"], TraditionalForm]], "InlineFormula"],
 " region, i.e. for low values of ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["p", "TI"], "\[LongEqual]", 
    StyleBox["i", "TI"]}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["q", "TI"], "\[LongEqual]", 
    StyleBox["i", "TI"]}], TraditionalForm]], "InlineFormula"],
 ". The maxima swap orderings between certain values of ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 " within a ",
 Cell[BoxData[
  FormBox[
   FractionBox["\[CapitalPi]", "6"], TraditionalForm]], "InlineFormula"],
 " region. This is evident in the inescapable indices of ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["i", "TI"], "-", "1"}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["i", "TI"], "+", "1"}], TraditionalForm]], "InlineFormula"],
 ", regardless of the starting values for ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 " for either the maxima or minima. So, whilst it is true that ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["a", "TI"], 
    StyleBox["i", "TI"], ">", 
    StyleBox["b", "TI"], 
    StyleBox["i", "TI"]}], TraditionalForm]], "InlineFormula"],
 ", it is not always true that ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["a", "TI"], 
    RowBox[{
     StyleBox["i", "TI"], "+", "1"}], ">", 
    StyleBox["b", "TI"], 
    RowBox[{
     StyleBox["i", "TI"], "-", "1"}]}], TraditionalForm]], "InlineFormula"],
 ". This leads to the question of what happens when this boundary ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["a", "TI"], 
    RowBox[{
     StyleBox["i", "TI"], "+", "1"}], "\[LongEqual]", 
    StyleBox["b", "TI"], 
    RowBox[{
     StyleBox["i", "TI"], "-", "1"}]}], TraditionalForm]], "InlineFormula"],
 " is crossed. Firstly, the even\[Hyphen]odd ordering (i.e. the a\[Hyphen]b \
channel ordering) is flipped; secondly, the indices are shifted. A second \
transition restores the a\[Hyphen]b ordering and shifts the indices again. As \
the index ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 " passes the half way point ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[LongEqual]", 
    SuperscriptBox["2", 
     RowBox[{
      StyleBox["n", "TI"], "-", "3"}]]}], TraditionalForm]], 
  "InlineFormula"],
 ", the transitions occur in the opposite direction, restoring the indices \
and ordering. Transitions occur where ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 " satisfies ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["a", "TI"], 
    RowBox[{
     StyleBox["i", "TI"], "+", "\[Iota]"}], "\[LongEqual]", 
    StyleBox["b", "TI"], 
    RowBox[{
     StyleBox["i", "TI"], "-", "\[Iota]"}]}], TraditionalForm]], 
  "InlineFormula"],
 ", with ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Iota]", "\[Element]", 
    RowBox[{"{", 
     RowBox[{"1", ",", "2", ",", "3", "\[CenterEllipsis]", 
      RowBox[{"(", 
       RowBox[{"7", "-", "4", 
        SqrtBox["3"]}], ")"}], 
      SuperscriptBox["2", 
       RowBox[{
        StyleBox["n", "TI"], "-", "3"}]]}], "}"}]}], TraditionalForm]], 
  "InlineFormula"],
 ". "
}], "Text"],

Cell["", "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          RowBox[{"\[LongEqual]", 
           SuperscriptBox["2", 
            RowBox[{
             StyleBox["n", "TI"], "-", "3"}]], "    ", 
           StyleBox["\[CapitalGamma]",
            FontSlant->"Italic"], 
           RowBox[{"(", 
            RowBox[{"\[Iota]", ",", 
             StyleBox["n", "TI"]}], ")"}], "\[LongEqual]", 
           SqrtBox[
            RowBox[{
             SuperscriptBox["\[Iota]", "2"], "-", "14", "\[Iota]", 
             SuperscriptBox["+", "2"]}]]}], "DisplayFormula"], 
         TraditionalForm]]]]]}
     },
     GridBoxAlignment->{
      "Columns" -> {{Right}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
       "RowsIndexed" -> {}}], TraditionalForm]]], 
  TraditionalForm]], "Equation",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[TextData[{
 "The region ",
 Cell[BoxData[
  FormBox["\[Iota]", TraditionalForm]], "InlineFormula"],
 " for a given value of ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 " is the highest value of ",
 Cell[BoxData[
  FormBox["\[Iota]", TraditionalForm]], "InlineFormula"],
 " for which the following condition remains true: "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell["", "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          RowBox[{"-", 
           StyleBox["\[CapitalGamma]",
            FontSlant->"Italic"], 
           RowBox[{"(", 
            RowBox[{"\[Iota]", ",", 
             StyleBox["n", "TI"]}], ")"}], "\[LessEqual]", 
           StyleBox["i", "TI"], "\[LessEqual]", 
           StyleBox["\[CapitalGamma]",
            FontSlant->"Italic"], 
           RowBox[{"(", 
            RowBox[{"\[Iota]", ",", 
             StyleBox["n", "TI"]}], ")"}], "+"}], "DisplayFormula"], 
         TraditionalForm]]]]]}
     },
     GridBoxAlignment->{
      "Columns" -> {{Right}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
       "RowsIndexed" -> {}}], TraditionalForm]]], 
  TraditionalForm]], "Equation",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell[TextData[{
 "For a given value of ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   StyleBox["n", "TI"], TraditionalForm]], "InlineFormula"],
 ", we can find the intersection index ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 ", and from this we can find ",
 Cell[BoxData[
  FormBox["\[Iota]", TraditionalForm]], "InlineFormula"],
 ": "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather*"}],

Cell["", "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather"}],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          RowBox[{
           StyleBox["i", "TI"], 
           RowBox[{"(", 
            RowBox[{"\[Delta]\[Theta]", ",", 
             StyleBox["n", "TI"]}], ")"}], "\[LongEqual]", 
           FractionBox[
            RowBox[{"tan", 
             RowBox[{"(", "\[Delta]\[Theta]", ")"}], 
             RowBox[{"(", 
              RowBox[{
               SqrtBox["3"], "tan", 
               RowBox[{"(", "\[Delta]\[Theta]", ")"}], "+", "7"}], ")"}]}], 
            RowBox[{"tan", 
             RowBox[{"(", "\[Delta]\[Theta]", ")"}], "+", 
             SqrtBox["3"]}]], "  ", "where", "  ", "\[Delta]\[Theta]", 
           "\[LongEqual]", 
           RowBox[{"\[Theta]", "  "}], "mod", 
           FractionBox[
            StyleBox["\[Pi]", "uniA"], "6"]}], "DisplayFormula"], 
         TraditionalForm]]]],
        CellTags->"eq:indexFromTheta"]},
      {Cell[TextData[Cell[BoxData[
        FormBox[
         StyleBox[
          RowBox[{"\[Iota]", 
           RowBox[{"(", 
            RowBox[{
             StyleBox["i", "TI"], ",", 
             StyleBox["n", "TI"]}], ")"}], "\[LongEqual]", 
           RowBox[{"\[LeftFloor]", 
            RowBox[{
             RowBox[{"7", " "}], "-", 
             SqrtBox[
              RowBox[{
               SuperscriptBox[
                StyleBox["i", "TI"], "2"], "-", "2", 
               StyleBox["i", "TI"], " ", "+", 
               RowBox[{"49", " "}], "2"}]]}], "\[RightFloor]"}]}], 
          "DisplayFormula"], TraditionalForm]]]]]}
     },
     GridBoxAlignment->{
      "Columns" -> {{Right}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
       "RowsIndexed" -> {}}], TraditionalForm]]], 
  TraditionalForm]], "NumberedEquation",
 TaggingRules:>{"Tex Macro Name" -> "gather"}],

Cell[TextData[{
 "The sequence of a\[Hyphen]b channel extrema depends on both the index ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 " and the region ",
 Cell[BoxData[
  FormBox["\[Iota]", TraditionalForm]], "InlineFormula"],
 " in the following way: "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[Cell[BoxData[
         FormBox[GridBox[{
            {Cell[TextData[Cell[BoxData[{
              StyleBox["b", "TI"], "\n", 
              RowBox[{
               StyleBox["i", "TI"], "-", "\[Iota]", "-", "1"}]}], 
              "InlineFormula"]]], Cell[TextData[Cell[
             "<", "InlineFormula"]]]},
            {Cell[TextData[Cell[BoxData[{
              StyleBox["a", "TI"], "\n", 
              RowBox[{
               StyleBox["i", "TI"], "+", "\[Iota]"}]}], "InlineFormula"]]], 
             Cell[TextData[Cell["<", "InlineFormula"]]]}
           },
           
           GridBoxAlignment->{
            "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
             "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
          TraditionalForm]]], TraditionalForm]], "InlineFormula"],
      " "
     }],
      CellTags->"eq:extremaBounds"], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         StyleBox["i", "TI"], Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["a", "TI"], "\n", 
               RowBox[{
                StyleBox["i", "TI"], "+", "\[Iota]", "+", "1"}]}], 
               "InlineFormula"]]]},
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["b", "TI"], "\n", 
               RowBox[{
                StyleBox["i", "TI"], "-", "\[Iota]"}]}], "InlineFormula"]]]}
            },
            
            GridBoxAlignment->{
             "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
              "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
           TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"when", "  ", Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[Cell[BoxData[{
               StyleBox["i", "TI"], "\n", "\[Element]", "\n", 
               RowBox[{"{", 
                RowBox[{"2", 
                 StyleBox["N",
                  FontSlant->"Plain"], "+", "1"}], "}"}]}], 
               "InlineFormula"]]], Cell[TextData[Cell[
              "\[Wedge]", "InlineFormula"]]], Cell[TextData[Cell[BoxData[{
              "\[Iota]", "\n", 
               RowBox[{
                RowBox[{"\[Element]", "\n", 
                 RowBox[{"{", 
                  RowBox[{"2", 
                   StyleBox["N",
                    FontSlant->"Plain"], "+", "1"}], "}"}]}], "\n", " "}], 
              "\n", "\[Vee]"}], "InlineFormula"]]]},
             {Cell[TextData[Cell[BoxData[{
               StyleBox["i", "TI"], "\n", "\[Element]", "\n", 
               RowBox[{"{", 
                RowBox[{"2", 
                 StyleBox["N",
                  FontSlant->"Plain"]}], "}"}]}], "InlineFormula"]]], Cell[
              TextData[Cell["\[Wedge]", "InlineFormula"]]], Cell[TextData[
              Cell[BoxData[{"\[Iota]", "\n", "\[Element]", "\n", 
               RowBox[{"{", 
                RowBox[{"2", 
                 StyleBox["N",
                  FontSlant->"Plain"]}], "}"}]}], "InlineFormula"]]]}
            },
            
            GridBoxAlignment->{
             "Columns" -> {Left, Center, {Left}}, "ColumnsIndexed" -> {}, 
              "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
           TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[Cell[BoxData[
         FormBox[GridBox[{
            {Cell[TextData[Cell[BoxData[{
              StyleBox["a", "TI"], "\n", 
              RowBox[{
               StyleBox["i", "TI"], "+", "\[Iota]"}]}], "InlineFormula"]]], 
             Cell[TextData[Cell["<", "InlineFormula"]]]},
            {Cell[TextData[Cell[BoxData[{
              StyleBox["b", "TI"], "\n", 
              RowBox[{
               StyleBox["i", "TI"], "-", "\[Iota]", "-", "1"}]}], 
              "InlineFormula"]]], Cell[TextData[Cell["<", "InlineFormula"]]]}
           },
           
           GridBoxAlignment->{
            "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
             "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
          TraditionalForm]]], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         StyleBox["i", "TI"], Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["b", "TI"], "\n", 
               RowBox[{
                StyleBox["i", "TI"], "-", "\[Iota]"}]}], "InlineFormula"]]]},
             {Cell[TextData[Cell["<", "InlineFormula"]]], Cell[TextData[Cell[
              BoxData[{
               StyleBox["a", "TI"], "\n", 
               RowBox[{
                StyleBox["i", "TI"], "+", "\[Iota]", "+", "1"}]}], 
               "InlineFormula"]]]}
            },
            
            GridBoxAlignment->{
             "Columns" -> {Center, {Center}}, "ColumnsIndexed" -> {}, 
              "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
           TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"when", "  ", Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[Cell[BoxData[{"(", "\n", 
               RowBox[{
                StyleBox["i", "TI"], "\[Element]", 
                RowBox[{"{", 
                 RowBox[{"2", 
                  StyleBox["N",
                   FontSlant->"Plain"], "+", "1"}], "}"}]}]}], 
               "InlineFormula"]]], Cell[TextData[Cell[
              "\[Wedge]", "InlineFormula"]]], Cell[TextData[Cell[BoxData[{
               RowBox[{
                RowBox[{
                 RowBox[{"\[Iota]", "\n", 
                  RowBox[{"\[Element]", "\n", 
                   RowBox[{"{", 
                    RowBox[{"2", 
                    StyleBox["N",
                    FontSlant->"Plain"]}], "}"}]}], "\n"}], ")"}], " "}], 
              "\n", "\[Vee]"}], "InlineFormula"]]]},
             {Cell[TextData[Cell[BoxData[{"(", "\n", 
               RowBox[{
                StyleBox["i", "TI"], "\[Element]", 
                RowBox[{"{", 
                 RowBox[{"2", 
                  StyleBox["N",
                   FontSlant->"Plain"]}], "}"}]}]}], "InlineFormula"]]], Cell[
              TextData[Cell["\[Wedge]", "InlineFormula"]]], Cell[TextData[
              Cell[BoxData[{"\[Iota]", "\n", "\[Element]", "\n", 
               RowBox[{"{", 
                RowBox[{"2", 
                 StyleBox["N",
                  FontSlant->"Plain"], "+", "1"}], "}"}], "\n", 
              ")"}], "InlineFormula"]]]}
            },
            
            GridBoxAlignment->{
             "Columns" -> {Left, Center, {Left}}, "ColumnsIndexed" -> {}, 
              "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
           TraditionalForm]]]}], TraditionalForm]], "InlineFormula"],
      " "
     }]]}
   },
   GridBoxAlignment->{
    "Columns" -> {Right, Center, {Left}}, "ColumnsIndexed" -> {}, 
     "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "gather"}],

Cell[TextData[{
 "We want to classify the points of intersection as greater or lesser than a \
tolerance ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", "<", "\[Tau]", "\[LessEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 ". In order to do this, we make a linear approximation to the perturbation \
between the extrema. There is one point of intersection between each of the \
maxima and corresponding minima. A bit of geometry allows us to write a \
classification criteria for each of the points of intersection. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather"}],

Cell[TextData[{
 "Defining a function for the degree of error at the point of intersection \
using the linear approximation from the four extrema surrounding the point, \
and generalizing to allow for different maximum errors ",
 Cell[BoxData[
  FormBox["\[Alpha]", TraditionalForm]], "InlineFormula"],
 " for channel ",
 Cell[BoxData[
  FormBox[
   StyleBox["a", "TI"], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["\[Beta]", TraditionalForm]], "InlineFormula"],
 " for channel b. The conditions on ",
 Cell[BoxData[
  FormBox[
   StyleBox["i", "TI"], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["\[Iota]", TraditionalForm]], "InlineFormula"],
 " can be more compactly written by applying a condition to their product. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "gather"}],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["h", "TI"], 
   RowBox[{"(", 
    RowBox[{
     StyleBox["i", "TI"], ",", "\[Iota]"}], ")"}], "\[LongEqual]", 
   RowBox[{"{", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             FractionBox[
              RowBox[{"\[Alpha]\[Beta]", "(", 
               RowBox[{
                StyleBox["a", "TI"], 
                RowBox[{
                 StyleBox["i", "TI"], "+", "\[Iota]"}], "-", 
                StyleBox["b", "TI"], 
                RowBox[{
                 StyleBox["i", "TI"], "-", "\[Iota]"}]}], ")"}], 
              RowBox[{"\[Beta]", 
               RowBox[{"(", 
                RowBox[{
                 StyleBox["a", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "+", "\[Iota]"}], "-", 
                 StyleBox["a", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "+", "\[Iota]", "+", "1"}]}], ")"}], 
               "+", "\[Alpha]", 
               RowBox[{"(", 
                RowBox[{
                 StyleBox["b", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "-", "\[Iota]", "-", "1"}], "-", 
                 StyleBox["b", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "-", "\[Iota]"}]}], ")"}]}]], 
             "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              StyleBox["i", "TI"], "+", "\[Iota]", "\[Element]", 
              RowBox[{"{", 
               RowBox[{"2", 
                StyleBox["N",
                 FontSlant->"Plain"]}], "}"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             FractionBox[
              RowBox[{"\[Alpha]\[Beta]", "(", 
               RowBox[{
                StyleBox["b", "TI"], 
                RowBox[{
                 StyleBox["i", "TI"], "-", "\[Iota]", "-", "1"}], "-", 
                StyleBox["a", "TI"], 
                RowBox[{
                 StyleBox["i", "TI"], "+", "\[Iota]", "+", "1"}]}], ")"}], 
              RowBox[{"\[Beta]", 
               RowBox[{"(", 
                RowBox[{
                 StyleBox["a", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "+", "\[Iota]"}], "-", 
                 StyleBox["a", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "+", "\[Iota]", "+", "1"}]}], ")"}], 
               "+", "\[Alpha]", 
               RowBox[{"(", 
                RowBox[{
                 StyleBox["b", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "-", "\[Iota]", "-", "1"}], "-", 
                 StyleBox["b", "TI"], 
                 RowBox[{
                  StyleBox["i", "TI"], "-", "\[Iota]"}]}], ")"}]}]], 
             "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              StyleBox["i", "TI"], "+", "\[Iota]", "\[Element]", 
              RowBox[{"{", 
               RowBox[{"2", 
                StyleBox["N",
                 FontSlant->"Plain"], "+", "1"}], "}"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]}
       },
       GridBoxAlignment->{
        "Columns" -> {Left, {Center}}, "ColumnsIndexed" -> {}, 
         "Rows" -> {{Baseline}}, "RowsIndexed" -> {}}], 
      TraditionalForm]]]}]}], TraditionalForm]], "NumberedEquation",
 TaggingRules:>{{"Tex Macro Name" -> "gather"}, {
   "Tex Macro Name" -> "matrix"}},
 CellTags->"eq:generalisedPerturbation"],

Cell[TextData[{
 "allows the criteria for a channel to be written as ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Tau]", "\[GreaterEqual]", 
    StyleBox["h", "TI"], 
    RowBox[{"(", 
     RowBox[{
      StyleBox["i", "TI"], ",", "\[Iota]"}], ")"}]}], TraditionalForm]], 
  "InlineFormula"],
 ". "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "The criteria ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Tau]", "\[LongEqual]", "\[Null]"}], TraditionalForm]], 
  "InlineFormula"],
 " with ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Alpha]", "\[LongEqual]", "\[Beta]"}], TraditionalForm]], 
  "InlineFormula"],
 " selects from either the odd values or the even values of i, because if ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["h", "TI"], 
    RowBox[{"(", 
     RowBox[{
      StyleBox["i", "TI"], ",", 
      StyleBox["n", "TI"]}], ")"}], "<", "\[Null]"}], TraditionalForm]], 
  "InlineFormula"],
 " is true, then ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["h", "TI"], 
    RowBox[{"(", 
     RowBox[{
      StyleBox["i", "TI"], "+", "1", ",", 
      StyleBox["n", "TI"]}], ")"}], "<", "\[Null]"}], TraditionalForm]], 
  "InlineFormula"],
 " is false and vice versa. There are ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["2", 
    RowBox[{
     StyleBox["n", "TI"], "-", "2"}]], TraditionalForm]], "InlineFormula"],
 " points of intersection and ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["2", 
    RowBox[{
     StyleBox["n", "TI"], "-", "3"}]], TraditionalForm]], "InlineFormula"],
 " which satisfy the criteria ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Tau]", "\[LongEqual]", 
    FractionBox["1", "2"]}], TraditionalForm]], "InlineFormula"],
 ". The algorithm as implemented in openCV leaves the decision about the \
criteria up to the programmer. The programmer chooses a value for ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " and selects a value for ",
 Cell[BoxData[
  FormBox["\[Tau]", TraditionalForm]], "InlineFormula"],
 ". The algorithm returns the nearest value of ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " which satisfies the condition defined by ",
 Cell[BoxData[
  FormBox["\[Tau]", TraditionalForm]], "InlineFormula"],
 ". The programmer then decides whether the suggested value for ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " is acceptable and either adopts the suggested value, or chooses a value as \
close as possible, accepting the possibility of errors. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "For example, in this project ",
 Cell[BoxData[
  FormBox[
   StyleBox["n", "TI"], TraditionalForm]], "InlineFormula"],
 " is 8, so ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Element]", 
    RowBox[{"{", 
     RowBox[{
      SuperscriptBox[
       RowBox[{"-", "2"}], 
       RowBox[{"8", "-", "2"}]], "\[CenterEllipsis]", 
      SuperscriptBox["2", 
       RowBox[{"8", "-", "2"}]]}], "}"}]}], TraditionalForm]], 
  "InlineFormula"],
 ", which gives ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["2", 
     RowBox[{"8", "-", "3"}]], "-", "1"}], TraditionalForm]], "InlineFormula"],
 " values in each ",
 Cell[BoxData[
  FormBox[
   FractionBox["\[Pi]", "6"], TraditionalForm]], "InlineFormula"],
 " region, producing a maximum perturbation of less than . In total, there \
are ",
 Cell[BoxData[
  FormBox[
   RowBox[{"12", 
    RowBox[{"(", 
     RowBox[{
      SuperscriptBox["2", 
       RowBox[{"8", "-", "3"}]], "-", "1"}], ")"}], "\[LongEqual]", "372"}], 
   TraditionalForm]], "InlineFormula"],
 " possible values for ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " which produces a maximum perturbation of less than . This would allow the \
destination pixel values to be expressed in 8\[Hyphen]bit numbers without \
error using a transformation matrix expressed in 6\[Hyphen]bit signed \
integers. The statistics performed to determine ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " are not demanding enough to justify rejecting a suggested value of theta \
within 1of the requested value. It is, however, important to know the value \
actually used in the algorithm, which is why the mechanism for adjusting ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " is separate from the color\[Hyphen]space algorithm and is under the \
control of the programmer. For instance, in the implementation below, the \
suggested value is accepted and used to adjust the statistical model, keeping \
all the values in correct correspondence. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Preservation of Color Information  ", "Section",
 CellChangeTimes->{3.633114972518466*^9},
 CellTags->"sec:PreservationOfColorInformation"],

Cell["\<\
The goal of the algorithm is to preserve all the information captured by the \
camera which relates to skin whilst discarding as much of the irrelevant \
information as possible. Given that edges and features often present as \
shadows and highlights, all the information captured in terms of luminosity \
will be regarded as relevant information, at least as far as the manipulation \
of individual pixel values is concerned. Considering the chromatic \
information, the importance of the pixel value will be directly determined by \
a Gaussian distribution. \
\>", "Text"],

Cell["\<\
Knowing the range of values produced by the rotation allows us to scale the \
transformation to fit into the range of the destination data type. If we have \
RGB pixel values in a given machine data type, the amount of information \
contained in each of those channels is equal to the number of values \
accessible in that data type. For example: for 8\[Hyphen]bit, unsigned \
integers, there are 256 possible values. After a rotation, we are interested \
in the amount of information which lies along the new axes. This is found \
simply by multiplying the range of the source data type by the length of the \
new axes found for the unit cube. To preserve all the information captured, \
we would therefore have to use a larger data type to store the new values. We \
are, however, only interested in a small region in the chromatic space. The \
question is, then, how to preserve the relevant information in a way \
consistent with the significance indicated by the aforementioned Gaussian \
distribution. \
\>", "Text"],

Cell["\<\
None of the rotated axes have lengths less than 1 for the unit RGB cube. For \
this reason we\[CloseCurlyQuote]ve written redistribution functions which \
perform any necessary type conversion whilst preserving the information in a \
controlled way; we can keep the information where it\[CloseCurlyQuote]s \
needed and discard it where it\[CloseCurlyQuote]s irrelevant. So although \
this is strictly beyond the normal meaning of a color space conversion, it is \
addressing a connected issue and belongs in the conversion. In terms of \
optimization, it is also the most efficient place in the code in which to \
perform this adjustment, allowing us to \[LongDash] for the sake of example \
\[LongDash] discard the details of the colors of a duck\[CloseCurlyQuote]s \
feathers whilst keeping the hues and tones of human skin. \
\>", "Text"],

Cell["\<\
We can use a function to redistribute the information contained on the longer \
axis onto the shorter axis, which can be expressed in the discrete \
representation of that axis necessitated by internal integer data types. \
There are three ways in which to implement the redistribution functions: \
\>", "Text"],

Cell[CellGroupData[{

Cell["Partition  ", "Subsection",
 CellChangeTimes->{3.6331149515682287`*^9},
 CellTags->"sec:Partition"],

Cell["\<\
The most straightforward redistribution method is to simply preserve the \
information in a 1\[Hyphen]to\[Hyphen]1 fashion within a region. The region \
can be defined in terms of the distribution Gaussian by specifying a \
significance level in terms of the variance or the standard deviation. \
\>", "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Linear  ", "Subsection",
 CellChangeTimes->{3.633114958878171*^9},
 CellTags->"sec:Linear"],

Cell[TextData[{
 "A slightly more sophisticated method is to use a linear redistribution. A \
linear distribution is equivalent to partitioning given a unit gradient. \
However, a linear redistribution function allows for the possibility of data \
compression. So then, in the case where the region of interest contains more \
information than can be expressed in the destination data type, a linear \
distribution function allows an even compression of the information from \
source to destination. \[NonBreakingSpace]",
 ButtonBox["Lee2002",
  BaseStyle->"Citation",
  ButtonData->"Lee2002",
  ButtonNote->"Lee2002"],
 " "
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["ERF (Gaussian Error Function)  ", "Subsection",
 CellChangeTimes->{3.633114930002302*^9},
 CellTags->"sec:ERF"],

Cell["\<\
The integral of the cumulative Gaussian (i.e. Error Function) allows the \
redistribution of the information on the axis in a way which selectively \
preserves the information about a point on the axis (i.e. the mean of the \
Gaussian), and then progressively discard the information as it falls into \
the tails of the Gaussian. So, it provides a non\[Hyphen]linear distribution \
of the information. The Gaussian can be seen as describing our interest in \
the information contained along the axis, so it\[CloseCurlyQuote]s logical to \
use the error function to redistribute the information. The disadvantage of \
this is simply the computational effort involved in generating the error \
function. \
\>", "Text"],

Cell["\<\
The error function distribution is mathematically correct, being directly \
related to the Gaussian fit. Computationally, there are two considerations: \
the numerical representation, and performance. The discrete representation of \
the numerics means that \[LongDash] for a significant number of possible \
distributions \[LongDash] distributing using the error function has little to \
no advantage (or indeed difference) from using a linear distribution. \
\>", "Text"],

Cell["\<\
Considering the preservation of information captured, mappings with a \
gradient greater than 1 are undesirable because they preserve all the \
information whilst being informatically wasteful in that there are \
functionally inaccessible discrete values in the destination range. Our \
stated aim is to preserve the information in the image pertaining to human \
skin; unevenly distributing this information across a discrete data type is \
not only wasteful in terms of memory, but also of processing resources \
because subsequent processing routines will treat the data as if it has a \
higher fidelity than it actually does. \
\>", "Text"],

Cell[TextData[{
 "To construct a distribution function, we first need to describe the \
relationship of the error function to the Gaussian fit, and then produce a \
function with the appropriate range and domain. For a Gaussian fit with an \
amplitude A, a mean of ",
 Cell[BoxData[
  FormBox["\[Mu]", TraditionalForm]], "InlineFormula"],
 ", and a standard deviation of ",
 Cell[BoxData[
  FormBox["\[Sigma]", TraditionalForm]], "InlineFormula"],
 ", where ",
 Cell[BoxData[
  FormBox["\[Mu]", TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]], "InlineFormula"],
 " lie in a source range ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " from ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " to ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". The cumulative distribution is found by integrating from ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " to the point ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]], "InlineFormula"],
 ", as can be seen in (",
 
 CounterBox["Section", "eq:ErfDefinition"],
 " ): "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SuperscriptBox["\[Integral]", "x"], 
   StyleBox["A", "TI"], 
   FractionBox[
    SuperscriptBox[
     StyleBox["e", "TI"], 
     RowBox[{"-", 
      FractionBox[
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{
          StyleBox["t", "TI"], "-", "\[Mu]"}], ")"}], "2"], 
       RowBox[{"2", 
        SuperscriptBox["\[Sigma]", "2"]}]]}]], 
    RowBox[{
     SqrtBox[
      RowBox[{"2", "\[Pi]"}]], "\[Sigma]"}]], 
   StyleBox["d", "TI"], 
   StyleBox["t", "TI"], "\[LongEqual]", 
   FractionBox["1", "2"], 
   StyleBox["A", "TI"], 
   RowBox[{"(", 
    RowBox[{"erf", 
     RowBox[{"(", 
      FractionBox[
       RowBox[{"x", "-", "\[Mu]"}], 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}], "-", "erf", 
     RowBox[{"(", 
      FractionBox[
       RowBox[{"-", "\[Mu]"}], 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}]}], ")"}]}], 
  TraditionalForm]], "NumberedEquation",
 CellTags->"eq:ErfDefinition"],

Cell[TextData[{
 "The Gaussian distribution and the cumulative distribution are shown in \
Figure\[NonBreakingSpace]",
 
 CounterBox["Section", "fig:ErrorFunctionGraph"],
 "  for some values chosen for illustrative purposes. All that is required \
now is to fix the range ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " to ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " for the domain ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " to ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". "
}], "Text"],

Cell[TextData[{
 "First, we determine the maximum value taken in the domain. This is simply \
found by evaluating the function at ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". It should be noted that \[LongDash] if the Gaussian distribution is well \
contained in the source domain \[LongDash] the maximum value should be equal \
to the amplitude. For the sake of simplicity, we\[CloseCurlyQuote]ll ignore \
the amplitude of the fitted Gaussian found previously as it is not relevant \
to the design of the redistribution function. So, to fix the range of the \
distribution function, we first scale to the range ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", "1"}], TraditionalForm]], "InlineFormula"],
 " by simply dividing through by the maximum value, and then re\[Hyphen]scale \
to the destination range ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[LongEqual]", "-"}], TraditionalForm]], "InlineFormula"],
 " and shift by ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["d", "TI"], 
   StyleBox["i", "TI"], 
   StyleBox["s", "TI"], 
   RowBox[{"(", 
    StyleBox["x", "TI"], ")"}], "\[LongEqual]", 
   FractionBox[
    RowBox[{
     RowBox[{"(", ")"}], "(", 
     RowBox[{"erf", 
      RowBox[{"(", 
       FractionBox[
        RowBox[{
         StyleBox["x", "TI"], "-", "\[Mu]"}], 
        RowBox[{
         SqrtBox["2"], "\[Sigma]"}]], ")"}], "-", "erf", 
      RowBox[{"(", 
       FractionBox[
        RowBox[{"-", "\[Mu]"}], 
        RowBox[{
         SqrtBox["2"], "\[Sigma]"}]], ")"}]}], ")"}], 
    RowBox[{"erf", 
     RowBox[{"(", 
      FractionBox[
       RowBox[{"-", "\[Mu]"}], 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}], "-", "erf", 
     RowBox[{"(", 
      FractionBox[
       RowBox[{"-", "\[Mu]"}], 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}]}]], "+"}], 
  TraditionalForm]], "NumberedEquation",
 CellTags->"eq:disFunction"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Efficiently Implementing the Distribution Function ", "Subsection",
 CellChangeTimes->{{3.633119473684432*^9, 3.633119484385284*^9}}],

Cell[TextData[{
 "Mathematically, the ERF distribution function\[NonBreakingSpace](",
 
 CounterBox["Section", "eq:disFunction"],
 " ) achieves all the stated objectives. However, on a device we are dealing \
with discrete numerics and limited processing power, so further analysis is \
required. Where we\[CloseCurlyQuote]re using a discrete domain and range, the \
distribution is usefully divided into three characteristic behaviours: where \
it is constant, where it preserves all the information, and where it \
selectively preserves information. Looking at the distribution, this divides \
the source domain into five regions: two where it is effectively constant, \
two where it is selective, and one region around the mean where it preserves \
all the information. In order to design an efficient algorithm, it is useful \
to identify the boundaries of these five regions. "
}], "Text",
 CellChangeTimes->{3.633119471964732*^9}],

Cell[CellGroupData[{

Cell["The Region Which Discards All Information ", "Subsubsection",
 CellChangeTimes->{3.6331149107218027`*^9}],

Cell[TextData[{
 "First, we need to identify where the distribution is effectively constant. \
This can be found by solving the following equation in the region and domain ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", "\[LessEqual]", 
    StyleBox["x", "TI"], "\[LessEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 " and then generalized to the specific discrete numerics: "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   FractionBox[
    RowBox[{"erf", 
     RowBox[{"(", 
      FractionBox["\[Mu]", 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}], "+", "erf", 
     RowBox[{"(", 
      FractionBox[
       RowBox[{
        StyleBox["x", "TI"], "-", "\[Mu]"}], 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}]}], 
    RowBox[{"erf", 
     RowBox[{"(", 
      FractionBox["\[Mu]", 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}], "-", "erf", 
     RowBox[{"(", 
      FractionBox[
       RowBox[{"\[Mu]", "-", "1"}], 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}]}]], "\[LongEqual]", 
   RowBox[{"dL", "  ", "where", "  ", "dL"}], "\[LongEqual]"}], 
  TraditionalForm]], "NumberedEquation",
 CellChangeTimes->{{3.6331208812117653`*^9, 3.633120883545951*^9}},
 CellTags->"eq:0to1"],

Cell[TextData[{
 "The solution is found for the source domain in the range ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", "1"}], TraditionalForm]], "InlineFormula"],
 " as: "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["x", "TI"], "\[LongEqual]", 
   SqrtBox["2"], "\[Sigma]", 
   SuperscriptBox["erf", 
    RowBox[{"-", "1"}]], 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{"dL", "-", "1"}], ")"}], "erf", 
     RowBox[{"(", 
      FractionBox["\[Mu]", 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}], "-", "dL", " ", "erf", 
     RowBox[{"(", 
      FractionBox[
       RowBox[{"\[Mu]", "-", "1"}], 
       RowBox[{
        SqrtBox["2"], "\[Sigma]"}]], ")"}]}], ")"}], "+", "\[Mu]"}], 
  TraditionalForm]], "NumberedEquation",
 CellTags->"eq:LowHigh"],

Cell[TextData[{
 "The boundaries of the regions ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], 
    SubscriptBox["<", "1"]}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], 
    SubscriptBox[">", "2"]}], TraditionalForm]], "InlineFormula"],
 " for ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], "\[Element]", 
    RowBox[{"{", "\[CenterEllipsis]", "}"}]}], TraditionalForm]], 
  "InlineFormula"],
 " or ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], 
    SubscriptBox["<", "1"]}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], 
    SubscriptBox[">", "2"]}], TraditionalForm]], "InlineFormula"],
 " for ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], "\[Element]", 
    RowBox[{"{", 
     RowBox[{"0", "\[CenterEllipsis]", "1"}], "}"}]}], TraditionalForm]], 
  "InlineFormula"],
 " can be written using the following helpful constants of the distribution. \
"
}], "Text"],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        SuperscriptBox["\[CapitalSigma]", "-"], TraditionalForm]], 
       "InlineFormula"],
      " "
     }],
      CellTags->"eq:DistributionConstants"], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "erf", 
         RowBox[{"(", 
          FractionBox[
           RowBox[{
            StyleBox["\[Mu]", "uniA"], "-", "1"}], 
           RowBox[{
            SqrtBox["2"], 
            StyleBox["\[Sigma]", "uniA"]}]], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        SuperscriptBox["\[CapitalSigma]", "+"], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "erf", 
         RowBox[{"(", 
          FractionBox[
           StyleBox["\[Mu]", "uniA"], 
           RowBox[{
            SqrtBox["2"], 
            StyleBox["\[Sigma]", "uniA"]}]], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["dL", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[LongEqual]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Kappa]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[LongEqual]", TraditionalForm]], "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 CellChangeTimes->{{3.633120890448477*^9, 3.6331208933922777`*^9}}],

Cell["", "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           SubscriptBox["\[Null]", "1"], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "\[Sigma]", 
            SqrtBox["2"], " ", 
            SuperscriptBox["erf", 
             RowBox[{"-", "1"}]], 
            RowBox[{"(", 
             RowBox[{
              RowBox[{"(", 
               RowBox[{"dL", "-", "1"}], ")"}], 
              SuperscriptBox["\[CapitalSigma]", "+"], "-", "dL", " ", 
              SuperscriptBox["\[CapitalSigma]", "-"]}], ")"}], "+", "\[Mu]"}],
            "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           SubscriptBox["\[Null]", "2"], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "\[Sigma]", 
            SqrtBox["2"], " ", 
            SuperscriptBox["erf", 
             RowBox[{"-", "1"}]], 
            RowBox[{"(", 
             RowBox[{
              RowBox[{"(", 
               RowBox[{"dL", "-", "1"}], ")"}], 
              SuperscriptBox["\[CapitalSigma]", "-"], "-", "dL", " ", 
              SuperscriptBox["\[CapitalSigma]", "+"]}], ")"}], "+", "\[Mu]"}],
            "DisplayFormula"], TraditionalForm]]],
        " "
       }]]},
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           SubscriptBox["\[Null]", "1"], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "+", 
            RowBox[{"(", 
             RowBox[{
              SubscriptBox["\[Null]", "1"], "(", 
              RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], ")"}]}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           SubscriptBox["\[Null]", "2"], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "+", 
            RowBox[{"(", 
             RowBox[{
              SubscriptBox["\[Null]", "2"], "(", 
              RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], ")"}]}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]]}
     }], TraditionalForm]]], TraditionalForm]], "NumberedEquation",
 CellTags->"eq:DiscardedRegionBounds"]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Region Which Keeps All Information", "Subsubsection",
 CellChangeTimes->{{3.633119517721067*^9, 3.633119535052372*^9}}],

Cell["\<\
 To find the region where all the information in the source domain is \
preserved, we differentiate the distribution and solve for where the gradient \
is equal to the destination range over the source range. This corresponds to \
the point at which a unit change in the source produces a unit change in the \
destination range: \
\>", "Text",
 CellChangeTimes->{3.6331195156475077`*^9}],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   FractionBox[
    RowBox[{
     SqrtBox[
      FractionBox["2", "\[Pi]"]], 
     SuperscriptBox[
      StyleBox["e", "TI"], 
      RowBox[{"-", 
       FractionBox[
        SuperscriptBox[
         RowBox[{"(", 
          RowBox[{
           StyleBox["x", "TI"], "-", "\[Mu]"}], ")"}], "2"], 
        RowBox[{"2", 
         SuperscriptBox["\[Sigma]", "2"]}]]}]]}], 
    RowBox[{"\[Sigma]", "(", 
     RowBox[{"erf", 
      RowBox[{"(", 
       FractionBox["\[Mu]", 
        RowBox[{
         SqrtBox["2"], "\[Sigma]"}]], ")"}], "-", "erf", 
      RowBox[{"(", 
       FractionBox[
        RowBox[{"\[Mu]", "-", "1"}], 
        RowBox[{
         SqrtBox["2"], "\[Sigma]"}]], ")"}]}], ")"}]], "\[LongEqual]"}], 
  TraditionalForm]], "NumberedEquation",
 CellChangeTimes->{3.6331208991730833`*^9},
 CellTags->"eq:Boundaries"],

Cell[TextData[{
 "Rearranging for ",
 Cell[BoxData[
  FormBox[
   StyleBox["x", "TI"], TraditionalForm]], "InlineFormula"],
 ", we find: "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["x", "TI"], "\[LongEqual]", "\[Mu]", "\[PlusMinus]", "\[Sigma]", 
   SqrtBox[
    RowBox[{
     RowBox[{
      RowBox[{"-", "2"}], "log", 
      RowBox[{"(", 
       RowBox[{"\[Sigma]", "(", 
        RowBox[{"erf", 
         RowBox[{"(", 
          FractionBox["\[Mu]", 
           RowBox[{
            SqrtBox["2"], "\[Sigma]"}]], ")"}], "-", "erf", 
         RowBox[{"(", 
          FractionBox[
           RowBox[{"\[Mu]", "-", "1"}], 
           RowBox[{
            SqrtBox["2"], "\[Sigma]"}]], ")"}]}], ")"}], ")"}]}], "+", 
     RowBox[{"2", 
      RowBox[{"log", "(", ")"}]}], "+", 
     RowBox[{"log", 
      RowBox[{"(", 
       FractionBox["2", "\[Pi]"], ")"}]}]}]]}], 
  TraditionalForm]], "NumberedEquation",
 CellChangeTimes->{3.6331209017235327`*^9},
 CellTags->"eq:PreservedRegion"],

Cell[TextData[{
 "The boundaries of the region ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[Null]", "1"], "<", 
    StyleBox["x", "TI"], 
    SubscriptBox["<", "2"]}], TraditionalForm]], "InlineFormula"],
 " for ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], "\[Element]", 
    RowBox[{"{", "\[CenterEllipsis]", "}"}]}], TraditionalForm]], 
  "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[Null]", "1"], "<", 
    StyleBox["x", "TI"], 
    SubscriptBox["<", "2"]}], TraditionalForm]], "InlineFormula"],
 " for ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["x", "TI"], "\[Element]", 
    RowBox[{"{", 
     RowBox[{"0", "\[CenterEllipsis]", "1"}], "}"}]}], TraditionalForm]], 
  "InlineFormula"],
 " can be written using the following helpful constants of the distribution. \
"
}], "Text"],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        SuperscriptBox["\[CapitalSigma]", "-"], TraditionalForm]], 
       "InlineFormula"],
      " "
     }],
      CellTags->"eq:DistributionConstants"], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "erf", 
         RowBox[{"(", 
          FractionBox[
           RowBox[{
            StyleBox["\[Mu]", "uniA"], "-", "1"}], 
           RowBox[{
            SqrtBox["2"], 
            StyleBox["\[Sigma]", "uniA"]}]], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        SuperscriptBox["\[CapitalSigma]", "+"], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "erf", 
         RowBox[{"(", 
          FractionBox[
           StyleBox["\[Mu]", "uniA"], 
           RowBox[{
            SqrtBox["2"], 
            StyleBox["\[Sigma]", "uniA"]}]], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Kappa]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         FractionBox[]}], TraditionalForm]], "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]]],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["w", "TI"], 
   RowBox[{"(", 
    RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], "\[LongEqual]", "\[Sigma]", 
   SqrtBox[
    RowBox[{"log", 
     RowBox[{"(", 
      FractionBox["2", "\[Pi]"], ")"}], "-", "2", "log", 
     RowBox[{"(", 
      RowBox[{"\[Kappa]\[Sigma]", "(", 
       RowBox[{
        SuperscriptBox["\[CapitalSigma]", "+"], "-", 
        SuperscriptBox["\[CapitalSigma]", "-"]}], ")"}], ")"}]}]]}], 
  TraditionalForm]], "NumberedEquation",
 CellTags->"eq:PreservedRegionConsts"],

Cell[TextData[{
 "The equations are found in the unit source domain ",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", ":", "1"}], TraditionalForm]], "InlineFormula"],
 ". It is a simple matter to scale and shift these values to give the points \
in a more general source domain. "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            SubscriptBox["\[Null]", "1"], "(", 
            RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "\[Mu]", "-", 
            StyleBox["w", "TI"], 
            RowBox[{"(", 
             RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            SubscriptBox["\[Null]", "2"], "(", 
            RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "\[Mu]", "+", 
            StyleBox["w", "TI"], 
            RowBox[{"(", 
             RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]]},
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            SubscriptBox["\[Null]", "1"], "(", 
            RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "+", 
            RowBox[{"(", 
             RowBox[{"\[Mu]", "-", 
              StyleBox["w", "TI"], 
              RowBox[{"(", 
               RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}], ")"}]}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            SubscriptBox["\[Null]", "2"], "(", 
            RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "+", 
            RowBox[{"(", 
             RowBox[{"\[Mu]", "+", 
              StyleBox["w", "TI"], 
              RowBox[{"(", 
               RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}], ")"}]}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]]}
     }], TraditionalForm]]], TraditionalForm]], "NumberedEquation",
 CellTags->"eq:PreservedRegionGen"],

Cell[TextData[{
 "One refinement can be made to these values by recognizing that the discrete \
distribution extends the effectively linear region past the analytic solution \
by rounding the values. This can be seen in ",
 
 CounterBox["Section", "fig:ExtensionToLinearRegion"],
 " , where the shaded squares are the rounded values. The extended region \
boundary ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " was found by numerically solving "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   RowBox[{"\[LeftFloor]", 
    RowBox[{"dis", "(", 
     SubscriptBox["\[Null]", "2"], ")"}], "\[RightFloor]"}], "+", 
   RowBox[{"(", 
    RowBox[{
     StyleBox["x", "TI"], 
     SubscriptBox["-", "2"]}], ")"}], "\[LongEqual]", "dis", 
   RowBox[{"(", 
    StyleBox["x", "TI"], ")"}]}], TraditionalForm]], "NumberedEquation"],

Cell[TextData[{
 "In the C++ code, whilst numerical routines were used MatLab and Mathematica \
to perform the analysis, the extended region boundary point was found by \
\[CloseCurlyQuote]walking\[CloseCurlyQuote] along the distribution from the \
analytic point ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["\[Null]", "2"], TraditionalForm]], "InlineFormula"],
 " until divergence from linear behaviour became apparent. This is regarded \
as a simpler solution, not requiring the use of numerical library routines, \
and proved to be a quick and elegant solution for the C++ implementation. The \
extended boundaries ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["\[Null]", "1"], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["\[Null]", "2"], TraditionalForm]], "InlineFormula"],
 " are then defined by "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            RowBox[{"\[LeftCeiling]", 
             RowBox[{"dis", "(", 
              SubscriptBox["\[Null]", "1"], ")"}], "\[RightCeiling]"}], 
            SubscriptBox["-", "1"]}], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "dis", 
            RowBox[{"(", 
             SubscriptBox["\[Null]", "1"], ")"}], 
            SubscriptBox["-", "1"]}], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{
            RowBox[{"\[LeftFloor]", 
             RowBox[{"dis", "(", 
              SubscriptBox["\[Null]", "2"], ")"}], "\[RightFloor]"}], 
            SubscriptBox["-", "2"]}], "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "dis", 
            RowBox[{"(", 
             SubscriptBox["\[Null]", "2"], ")"}], 
            SubscriptBox["-", "2"]}], "DisplayFormula"], TraditionalForm]]],
        " "
       }]]}
     }], TraditionalForm]]], TraditionalForm]], "NumberedEquation"]
}, Open  ]],

Cell[CellGroupData[{

Cell["The compression ratio ", "Subsubsection",
 CellChangeTimes->{3.633119618128394*^9}],

Cell["\<\
There is one final value of interest to the development of the algorithm, \
which is the gradient at the mean. The reason this is of interest is because \
we\[CloseCurlyQuote]re trying to compress the relevant data as much as \
possible. If the destination region is small (i.e. the destination machine \
type is smaller than the source type), then the gradient at the mean allows \
us to assess the fidelity required of the source type. If it weren\
\[CloseCurlyQuote]t for the fact that the source is the result of a rotation \
transformation, then there would be little purpose in assessing this value. \
However, it is entirely possible that the lengthening of the axes resulting \
from the rotation is insignificant for the desired destination type; there\
\[CloseCurlyQuote]s no point preserving information during the rotation which \
is then discarded by the redistribution. The gradient is given by \
\>", "Text"],

Cell[TextData[{
 "The compression ratio is at most one\[Hyphen]to\[Hyphen]one, therefore ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Kappa]", "<", "\[LongEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 " and the gradient in the unit space must always be greater than one ",
 Cell[BoxData[
  FormBox[
   RowBox[{"1", "\[LessEqual]", "\[Delta]", 
    RowBox[{"(", 
     RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}], TraditionalForm]], 
  "InlineFormula"],
 ". so ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Kappa]", "\[LessEqual]", "\[CapitalDelta]", 
    RowBox[{"(", 
     RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], "\[LessEqual]", "\[Delta]", 
    RowBox[{"(", 
     RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}], TraditionalForm]], 
  "InlineFormula"],
 ". "
}], "Text"],

Cell[TextData[{
 "The required fidelity in the source domain can be found using ",
 Cell[BoxData[
  FormBox["\[CapitalDelta]", TraditionalForm]], "InlineFormula"],
 " in the sense that the correspondence between one information step in the \
source must produce a step of ",
 Cell[BoxData[
  FormBox["\[CapitalDelta]", TraditionalForm]], "InlineFormula"],
 " in the destination type. For the algorithm evaluating the maximum gradient \
",
 Cell[BoxData[
  FormBox["\[CapitalDelta]", TraditionalForm]], "InlineFormula"],
 " allows us to be sure that ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " \[LongDash] the region on the x axis where all the information is to be \
preserved \[LongDash] exists if ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[CapitalDelta]", ">", "1"}], TraditionalForm]], 
  "InlineFormula"],
 " or tells us that the x axis can be shortened if ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[CapitalDelta]", "<", "1"}], TraditionalForm]], 
  "InlineFormula"],
 ". In the algorithm ",
 Cell[BoxData[
  FormBox["\[CapitalDelta]", TraditionalForm]], "InlineFormula"],
 " is used to find an appropriate working data type for the rotated color \
space and to define the axis scaling for the rotation matrix. "
}], "Text"],

Cell[TextData[{
 "We need to consider the requested compression of information alongside the \
spread of information caused by the rotation, and the desired focus on the \
specific region of interest dictated by the statistics. Each axis in the \
color space is to be represented by a discrete set of numbers. The size of \
these sets dictates the discretization of the axis, and the ratios between \
them indicates the spread or compression of the information they contain. We \
assume that the RGB axes are each discretized to the same extent, each \
containing ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " values. After the application of the un\[Hyphen]normalized rotational \
transformation, the axes contain differing numbers of values given by ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[Null]", "1"], 
    RowBox[{"\[LongEqual]", " "}], 
    SqrtBox["3"]}], TraditionalForm]], "InlineFormula"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[Null]", "2"], 
    RowBox[{"\[LongEqual]", " "}], 
    SubscriptBox[
     StyleBox["L", "TI"], "2"], 
    RowBox[{"(", "\[Theta]", ")"}]}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[Null]", "3"], 
    RowBox[{"\[LongEqual]", " "}], 
    SubscriptBox[
     StyleBox["L", "TI"], "3"], 
    RowBox[{"(", "\[Theta]", ")"}]}], TraditionalForm]], "InlineFormula"],
 ". These axis lengths preserve all the information contained in the source \
color space, and so are the maximum length the axis should take. The minumum \
length the axis may take is where the information is lost evenly throuought \
the axis, and corresponds to an axis length equal to the destination axis \
length ",
 Cell[BoxData[
  FormBox["\[LongEqual]", TraditionalForm]], "InlineFormula"],
 ". "
}], "Text"],

Cell[TextData[{
 "We can now write an algorithm which determines the necessary scaling for \
the axes, and whether truncation of the extreme values is significant. As \
this will alter ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " we fix the values of ",
 Cell[BoxData[
  FormBox["\[Kappa]", TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["\[CapitalDelta]", TraditionalForm]], "InlineFormula"],
 " to be those for the working range ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[LongEqual]", 
    StyleBox["L",
     FontSlant->"Bold"], 
    RowBox[{"(", "\[Theta]", ")"}]}], TraditionalForm]], "InlineFormula"],
 " which preserves all information. With this value the constants are  \n\
{{Cell[TextData[{\" \", Cell[BoxData[FormBox[StyleBox[\"K\", \"TI\"], \
TraditionalForm]], \"InlineFormula\"], \" \"}]], Cell[TextData[{\" \", \
Cell[BoxData[FormBox[RowBox[{\"\[LongEqual]\", FractionBox[]}], \
TraditionalForm]], \"InlineFormula\"], \" \"}]], Cell[TextData[{\" \", \
Cell[BoxData[FormBox[RowBox[{\"\[Kappa]\", \"(\", \"\[Theta]\", \")\"}], \
TraditionalForm]], \"InlineFormula\"], \" \"}]], Cell[TextData[{\" \", \
Cell[BoxData[FormBox[RowBox[{\"\[LongEqual]\", FractionBox[StyleBox[\"K\", \
\"TI\"], RowBox[{StyleBox[\"L\", FontSlant -> \"Bold\"], \"(\", \"\[Theta]\", \
\")\"}]]}], TraditionalForm]], \"InlineFormula\"], \" \"}]], \
Cell[TextData[{\" \", Cell[BoxData[FormBox[RowBox[{\"\[CapitalDelta]\", \
\"(\", RowBox[{\"\[Mu]\", \",\", \"\[Sigma]\"}], \")\"}], TraditionalForm]], \
\"InlineFormula\"], \" \"}]], Cell[TextData[{\" \", \
Cell[BoxData[FormBox[RowBox[{\"\[LongEqual]\", FractionBox[StyleBox[\"K\", \
\"TI\"], RowBox[{StyleBox[\"L\", FontSlant -> \"Bold\"], \"(\", \"\[Theta]\", \
\")\"}]], \"\[Delta]\", RowBox[{\"(\", RowBox[{\"\[Mu]\", \",\", \
\"\[Sigma]\"}], \")\"}]}], TraditionalForm]], \"InlineFormula\"], \" \
\"}]]}}The length of the axis ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " after rescaling should be "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"(", 
            RowBox[{"\[Theta]", ",", "\[Mu]", ",", "\[Sigma]"}], ")"}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "min", 
            RowBox[{"{", 
             RowBox[{
              FractionBox[
               StyleBox["K", "TI"], 
               RowBox[{
                StyleBox["L",
                 FontSlant->"Bold"], "(", "\[Theta]", ")"}]], "\[Delta]", 
              RowBox[{"(", 
               RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], ",", "1"}], "}"}], 
            StyleBox["L",
             FontSlant->"Bold"], 
            RowBox[{"(", "\[Theta]", ")"}]}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]]},
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox["\[Null]", "DisplayFormula"], TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "min", 
            RowBox[{"{", 
             RowBox[{
              StyleBox["K", "TI"], "\[Delta]", 
              RowBox[{"(", 
               RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}]}], ",", 
            RowBox[{
             RowBox[{
              StyleBox["L",
               FontSlant->"Bold"], "(", "\[Theta]", ")"}], "}"}]}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]]}
     }], TraditionalForm]]], TraditionalForm]], "NumberedEquation",
 CellTags->"eq:CombinedRotationRange"],

Cell[TextData[{
 "The scaling ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " comes from the source pixel values, the remaining terms translates simply \
into a rotation matrix scaling  "
}], "Text"],

Cell[TextData[{
 "This satisfies the requirements placed on the gradient ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[CapitalDelta]", 
    RowBox[{"(", 
     RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], ">", "1"}], TraditionalForm]],
   "InlineFormula"],
 " because: if we substitute for ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " in the definition for the gradient ",
 
 CounterBox["Section", "eq:gradient"],
 "  "
}], "Text"],

Cell["", "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[CapitalDelta]", "(", 
            RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "max", 
            RowBox[{"{", 
             RowBox[{
              FractionBox[
               StyleBox["K", "TI"], 
               RowBox[{
                StyleBox["L",
                 FontSlant->"Bold"], "(", "\[Theta]", ")"}]], "\[Delta]", 
              RowBox[{"(", 
               RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}], ",", "1"}], "}"}]}],
            "DisplayFormula"], TraditionalForm]]],
        " "
       }]]}
     }], TraditionalForm]]], TraditionalForm]], "NumberedEquation",
 CellTags->"eq:newGradient"],

Cell[TextData[{
 "And the compression ratio ",
 Cell[BoxData[
  FormBox["\[Kappa]", TraditionalForm]], "InlineFormula"],
 " is also explicitly restricted to being at most one and now is no longer \
defined in terms of ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". "
}], "Text"],

Cell[BoxData[
 FormBox[Cell[BoxData[
   FormBox[GridBox[{
      {Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[Kappa]", "(", "\[Theta]", ")"}], "DisplayFormula"], 
          TraditionalForm]]],
        " "
       }]], Cell[TextData[{
        " ",
        Cell[BoxData[
         FormBox[
          StyleBox[
           RowBox[{"\[LongEqual]", "max", 
            RowBox[{"{", 
             RowBox[{
              FractionBox["1", 
               RowBox[{"\[Delta]", "(", 
                RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]], ",", 
              FractionBox[
               StyleBox["K", "TI"], 
               RowBox[{
                StyleBox["L",
                 FontSlant->"Bold"], "(", "\[Theta]", ")"}]]}], "}"}]}], 
           "DisplayFormula"], TraditionalForm]]],
        " "
       }]]}
     }], TraditionalForm]]], TraditionalForm]], "NumberedEquation",
 CellTags->"eq:newCompressionRatio"]
}, Open  ]],

Cell[CellGroupData[{

Cell["A Piecewise Approximation to the ERF Distribution ", "Subsubsection",
 CellChangeTimes->{{3.6331196341140423`*^9, 3.633119647592169*^9}}],

Cell["\<\
We now have equations which give us the four points in the source domain \
which mark the boundaries of the five characteristic regions. We can now use \
them to define a piecewise function which uses the computationally \
problematic error function based distribution as little as possible \
\>", "Text",
 CellChangeTimes->{3.633119632660562*^9}],

Cell["", "Text"],

Cell[BoxData[
 FormBox[
  RowBox[{
   StyleBox["p", "TI"], 
   StyleBox["D", "TI"], 
   StyleBox["i", "TI"], 
   StyleBox["s", "TI"], 
   RowBox[{"(", 
    StyleBox["x", "TI"], ")"}], "\[LongEqual]", 
   RowBox[{"{", Cell[BoxData[
     FormBox[GridBox[{
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox["\[Null]", "DisplayFormula"], TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              StyleBox["x", "TI"], 
              SubscriptBox["\[LessEqual]", "1"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"dis", "(", 
              StyleBox["x", "TI"], ")"}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              SubscriptBox["\[Null]", "1"], "<", 
              StyleBox["x", "TI"], 
              SubscriptBox["<", "1"]}], "DisplayFormula"], TraditionalForm]]],
          
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              StyleBox["x", "TI"], 
              SubscriptBox["-", "1"], "+", "dis", 
              RowBox[{"(", 
               SubscriptBox["\[Null]", "1"], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              SubscriptBox["\[Null]", "1"], "\[LessEqual]", 
              StyleBox["x", "TI"], 
              SubscriptBox["\[LessEqual]", "2"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"dis", 
              RowBox[{"(", 
               StyleBox["x", "TI"], ")"}], 
              SubscriptBox["+", "2"], 
              SubscriptBox["-", "1"], "-", "dis", 
              RowBox[{"(", 
               SubscriptBox["\[Null]", "2"], ")"}], "+", "dis", 
              RowBox[{"(", 
               SubscriptBox["\[Null]", "1"], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              SubscriptBox["\[Null]", "2"], "<", 
              StyleBox["x", "TI"], 
              SubscriptBox["<", "2"]}], "DisplayFormula"], TraditionalForm]]],
          
          " "
         }]]},
        {Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{"dis", 
              RowBox[{"(", 
               SubscriptBox["\[Null]", "2"], ")"}], 
              SubscriptBox["+", "2"], 
              SubscriptBox["-", "1"], "-", "dis", 
              RowBox[{"(", 
               SubscriptBox["\[Null]", "2"], ")"}], "+", "dis", 
              RowBox[{"(", 
               SubscriptBox["\[Null]", "1"], ")"}]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]], Cell[TextData[{
          " ",
          Cell[BoxData[
           FormBox[
            StyleBox[
             RowBox[{
              StyleBox["x", "TI"], 
              SubscriptBox["\[GreaterEqual]", "2"]}], "DisplayFormula"], 
            TraditionalForm]]],
          " "
         }]]}
       }], TraditionalForm]]]}]}], TraditionalForm]], "NumberedEquation",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "All three distribution techniques ( ",
 
 CounterBox["Section", "sec:Partition"],
 "  , ",
 
 CounterBox["Section", "sec:Linear"],
 "  , ",
 
 CounterBox["Section", "sec:ERF"],
 "  ) described earlier are special cases of this distribution. When the \
distribution has a very large variance the piecewise distribution can be \
simplified as a linear distribution fig",
 
 CounterBox["Section", "fig:useLinear"],
 " . When the distribution has a very small variance a partitioning is more \
appropriate fig ",
 
 CounterBox["Section", "fig:usePartitioning"],
 " . The most interesting distributions, however, are the ones which require \
the use of the piecewise distribution fig ",
 
 CounterBox["Section", "fig:usePiecewiseERF"],
 " .  "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Skin Color Space Algorithm ", "Section",
 CellChangeTimes->{3.633119670135826*^9}],

Cell[TextData[{
 "Now that all of the values necessary to preserve the skin information have \
been obtained, we can use them to build a color space transformation \
algorithm which can make intelligent decisions about the numerical precision \
for the intermediate and final variables, as well as determining the most \
efficient transformation methods. The algorithm described herein will take \
values of ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 ", the rotation about the luminosity axis, the standard deviations ",
 Cell[BoxData[
  FormBox[
   StyleBox["a", "TI"], TraditionalForm]], "InlineFormula"],
 ",",
 Cell[BoxData[
  FormBox[
   StyleBox["b", "TI"], TraditionalForm]], "InlineFormula"],
 " and mean values ",
 Cell[BoxData[
  FormBox[
   StyleBox["a", "TI"], TraditionalForm]], "InlineFormula"],
 ",",
 Cell[BoxData[
  FormBox[
   StyleBox["b", "TI"], TraditionalForm]], "InlineFormula"],
 " for the two chromatic axes in the unit range and will automatically decide \
upon the necessary intermediate working data types and the most efficient \
redistribution methods. "
}], "Text"],

Cell[TextData[{
 "Previously, we found a rotational transformation which allows a working \
type ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " to be chosen such that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[LessEqual]", "2"}], TraditionalForm]], "InlineFormula"],
 ". If we were to keep the same data type for the color space ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " as is used for the RGB values ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ", then the axes would have to be rescaled with the accompanying loss of \
information. Given that we have values which allow us to assess where all the \
relevant information lies, a more sophisticated approach is possible. For a \
chromatic axis \[LongDash] which, after rotation, has a length ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    StyleBox["L", "TI"], "(", "\[Theta]", ")"}], TraditionalForm]], 
  "InlineFormula"],
 " \[LongDash] we can determine the positions on that axis at which the \
information is considered irrelevant using Equation\[NonBreakingSpace](",
 
 CounterBox["Section", "eq:LowHigh"],
 " ) and the positions where the information is all considered relevant. If \
the gradient ",
 Cell[BoxData[
  FormBox["\[CapitalDelta]", TraditionalForm]], "InlineFormula"],
 " ",
 
 CounterBox["Section", "eq:gradient"],
 "  is less than 1, then the distribution loses information at all points on \
the axis and the axis can be shortened without loss of relevant information. \
The only further consideration is to ensure that the values outside that \
range are prevented from causing errors associated with overflow. To exclude \
this possibility, a conditional statement can be used which checks the bounds \
as stated, assigning an appropriate value as necessary. The alternative is to \
use an intermediate value with a higher bit depth, and then to recast into \
the destination data type in such a way that overflow and underflow are \
handled appropriately. The OpenCV library provides a casting method \
\[LongDash] saturateCast \[LongDash] which serves this purpose. "
}], "Text"],

Cell[CellGroupData[{

Cell["Setting the Value for the Tolerance ", "Subsubsection",
 CellChangeTimes->{{3.633119689674574*^9, 3.633119712982277*^9}}],

Cell[TextData[{
 "Now that we have the working type range ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ", accounting for both the rotation and the statistics, we can set a \
meaningful tolerance on the error. Previously we calculated that the maximum \
error would occur for pixel values at the corners of the RGB cube, we have \
now seen that some values are more important than others and that it is more \
meaningful to use a smaller RGB cube which encloses only the values of \
interest. This cube is found by taking the values for ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " as the corners in the rotated space and rotating back to the RGB space. As \
this only needs to be done once it can be performed using floats in the unit \
spaces however the values of ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " account for the discrete numerics in that they are calculated from the \
discrete values ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " using the new values for ",
 Cell[BoxData[
  FormBox["\[Kappa]", TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 ". In order to perform the inverse rotation the values must be shifted to \
compensate for the natural range of the rotation which is ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{
    "0", ":", "1", ",", "-", "\[Null]", ":", "\[Null]", ",", "-", "\[Null]", 
     ":", "\[Null]"}], "}"}], TraditionalForm]], "InlineFormula"],
 ". "
}], "Text",
 CellChangeTimes->{3.633119687084944*^9}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        SubsuperscriptBox["\[Null]", "2", 
         StyleBox[
          RowBox[{"R", "G", "B"}], "TI"]], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         SuperscriptBox["\[LongEqual]", 
          RowBox[{"-", "1"}]], "\[CenterDot]", 
         RowBox[{"(", 
          RowBox[{
           SubscriptBox["\[Null]", "2"], "-"}], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"where", "  ", "\[LongEqual]", 
         RowBox[{"(", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox["1", 2]], "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell[BoxData[
                 FormBox["1", 2]], "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]},
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{
         SuperscriptBox["\[LongEqual]", 
          StyleBox["T", "TI"]], "\[CenterDot]", 
         RowBox[{"(", 
          RowBox[{"\[CircleTimes]", "(", 
           RowBox[{
            SubscriptBox["\[Null]", "2"], "-"}], ")"}], ")"}]}], 
        TraditionalForm]], "InlineFormula"],
      " "
     }]], "\[Null]"}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "Because rotations of any angle are allowed the values for ",
 Cell[BoxData[
  FormBox[
   SubsuperscriptBox["\[Null]", "1", 
    StyleBox[
     RowBox[{"R", "G", "B"}], "TI"]], TraditionalForm]], "InlineFormula"],
 " may be larger than those for ",
 Cell[BoxData[
  FormBox[
   SubsuperscriptBox["\[Null]", "2", 
    StyleBox[
     RowBox[{"R", "G", "B"}], "TI"]], TraditionalForm]], "InlineFormula"],
 " in the RGB space. A smart programmer could actually take advantage of \
this. The values may also be outside the RGB cube meaning that the values may \
have to be truncated to fit inside the RGB cube range. "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "The perturbation to the rotated channel elements ",
 Cell[BoxData[
  FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
 " is found for an input set of pixel values ",
 Cell[BoxData[
  FormBox[
   SubsuperscriptBox["\[Null]", "2", 
    StyleBox[
     RowBox[{"R", "G", "B"}], "TI"]], TraditionalForm]], "InlineFormula"],
 " "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox["\[Null]", TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", "min", 
         RowBox[{"{", 
          RowBox[{
           StyleBox["K", "TI"], "\[Delta]", 
           RowBox[{"(", 
            RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}]}], ",", 
         RowBox[{
          RowBox[{
           StyleBox["L",
            FontSlant->"Bold"], "(", "\[Theta]", ")"}], "}"}], 
         "\[CircleTimes]", 
         RowBox[{"(", Cell[BoxData[
           FormBox[GridBox[{
              {Cell[TextData[{
                " ",
                Cell["0", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell["2", "InlineFormula"],
                " "
               }]]},
              {Cell[TextData[{
                " ",
                Cell["2", "InlineFormula"],
                " "
               }]]}
             }], TraditionalForm]]], ")"}], "\[CircleTimes]", 
         RowBox[{"[", 
          RowBox[{"(", Cell[BoxData[
            FormBox[GridBox[{
               {Cell[TextData[{
                 " ",
                 Cell["0", "InlineFormula"],
                 " "
                }]]},
               {Cell[TextData[{
                 " ",
                 Cell[BoxData[{"[", "\n", "]"}], "InlineFormula"],
                 " "
                }]]},
               {Cell[TextData[{
                 " ",
                 Cell[BoxData[{"[", "\n", 
                  RowBox[{"6", "-"}], "\n", "]"}], "InlineFormula"],
                 " "
                }]]}
              }], TraditionalForm]]], ")"}], "]"}], "\[CircleTimes]", 
         RowBox[{"(", 
          RowBox[{
           RowBox[{"[", "\[Theta]", "]"}], 
           SubsuperscriptBox["\[CenterDot]", "2", 
            StyleBox[
             RowBox[{"R", "G", "B"}], "TI"]]}], ")"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "We have previously solved the case where both channels are of equal \
importance we now need to find the values of ",
 Cell[BoxData[
  FormBox["\[Alpha]", TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox["\[Beta]", TraditionalForm]], "InlineFormula"],
 " which set the relative importance of each channel. There are two factors \
here, the channel scaling and the new smaller RGB cube corners. The values \
for these also need to be put in correct correspondence with the ",
 Cell[BoxData[
  FormBox[
   StyleBox["a", "TI"], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   StyleBox["b", "TI"], TraditionalForm]], "InlineFormula"],
 " channel functions. For the scaling this is found by:  "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"(", Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[{
               " ",
               Cell["0", "InlineFormula"],
               " "
              }]]},
             {Cell[TextData[{
               " ",
               Cell[BoxData[
                FormBox["\[Alpha]", 1]], "InlineFormula"],
               " "
              }]]},
             {Cell[TextData[{
               " ",
               Cell[BoxData[
                FormBox["\[Beta]", 1]], "InlineFormula"],
               " "
              }]]}
            }], TraditionalForm]]], ")"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", 
          RowBox[{"min", 
           RowBox[{"{", 
            RowBox[{
             StyleBox["K", "TI"], "\[Delta]", 
             RowBox[{"(", 
              RowBox[{"\[Mu]", ",", "\[Sigma]"}], ")"}]}]}], ",", 
           RowBox[{
            RowBox[{
             StyleBox["L",
              FontSlant->"Bold"], "(", "\[Theta]", ")"}], "}"}], 
           "\[CircleTimes]", 
           RowBox[{"(", Cell[BoxData[
             FormBox[GridBox[{
                {Cell[TextData[{
                  " ",
                  Cell["0", "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell["2", "InlineFormula"],
                  " "
                 }]]},
                {Cell[TextData[{
                  " ",
                  Cell["2", "InlineFormula"],
                  " "
                 }]]}
               }], TraditionalForm]]], ")"}]}], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "For the new RGB corners we need to find the largest element which can \
result from the inner product with ",
 Cell[BoxData[
  FormBox[
   RowBox[{"[", "\[Theta]", "]"}], TraditionalForm]], "InlineFormula"],
 ". As the elements of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"[", "\[Theta]", "]"}], TraditionalForm]], "InlineFormula"],
 " are in ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{
     RowBox[{"-", "1"}], ",", "0", ",", "1"}], "}"}], TraditionalForm]], 
  "InlineFormula"],
 " with only one occurrence of each in the second and third rows we need to \
find the largest element of ",
 Cell[BoxData[
  FormBox[
   SubsuperscriptBox["\[Null]", "2", 
    StyleBox[
     RowBox[{"R", "G", "B"}], "TI"]], TraditionalForm]], "InlineFormula"],
 " which is not in the zero position. The algorithm solves: "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[BoxData[
 FormBox[GridBox[{
    {Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"(", Cell[BoxData[
          FormBox[GridBox[{
             {Cell[TextData[{
               " ",
               Cell["0", "InlineFormula"],
               " "
              }]]},
             {Cell[TextData[{
               " ",
               Cell[BoxData[
                FormBox["\[Alpha]", 2]], "InlineFormula"],
               " "
              }]]},
             {Cell[TextData[{
               " ",
               Cell[BoxData[
                FormBox["\[Beta]", 2]], "InlineFormula"],
               " "
              }]]}
            }], TraditionalForm]]], ")"}], TraditionalForm]], "InlineFormula"],
      " "
     }]], Cell[TextData[{
      " ",
      Cell[BoxData[
       FormBox[
        RowBox[{"\[LongEqual]", 
         RowBox[{"[", 
          RowBox[{"max", 
           RowBox[{"{", 
            RowBox[{"abs", 
             RowBox[{"(", 
              RowBox[{"[", "\[Theta]", "]"}], ")"}], "\[CircleTimes]", 
             SuperscriptBox[
              RowBox[{"(", 
               SubsuperscriptBox["\[Null]", "2", 
                StyleBox[
                 RowBox[{"R", "G", "B"}], "TI"]], ")"}], 
              StyleBox["T", "TI"]]}], "}"}]}], "]"}]}], TraditionalForm]], 
       "InlineFormula"],
      " "
     }]]}
   }], TraditionalForm]],
 TaggingRules:>{"Tex Macro Name" -> "matrix"}],

Cell[TextData[{
 "where ",
 Cell[BoxData[
  FormBox["max", TraditionalForm]], "InlineFormula"],
 " acts on each row and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"abs", 
    RowBox[{"(", 
     RowBox[{"[", "\[Theta]", "]"}], ")"}], "\[LongEqual]", 
    RowBox[{"[", "\[Theta]", "]"}], "\[CircleTimes]", 
    RowBox[{"[", "\[Theta]", "]"}]}], TraditionalForm]], "InlineFormula"],
 ". These then give a combined value for ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Alpha]", "\[LongEqual]", 
    SubscriptBox["\[Alpha]", "1"], 
    SubscriptBox["\[Alpha]", "2"]}], TraditionalForm]], "InlineFormula"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Beta]", "\[LongEqual]", 
    SubscriptBox["\[Beta]", "1"], 
    SubscriptBox["\[Beta]", "2"]}], TraditionalForm]], "InlineFormula"],
 ". Because the axis have been scaled so that the information on the axis is \
to be kept at least near the mean the tolerance should be set to ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Tau]", "\[LongEqual]", "1"}], TraditionalForm]], 
  "InlineFormula"],
 " the condition for accepting a value of ",
 Cell[BoxData[
  FormBox["\[Theta]", TraditionalForm]], "InlineFormula"],
 " ",
 Cell[BoxData[
  FormBox[
   RowBox[{"1", ">", 
    StyleBox["h", "TI"], 
    RowBox[{"(", 
     RowBox[{
      StyleBox["i", "TI"], ",", "\[Iota]", ";", "\[Alpha]", ",", "\[Beta]"}], 
     ")"}]}], TraditionalForm]], "InlineFormula"],
 " can be used.  "
}], "Text",
 TaggingRules:>{"Tex Macro Name" -> "matrix"}]
}, Open  ]]
}, Open  ]]
}, Open  ]]
},
WindowSize->{808, 655},
WindowMargins->{{12, Automatic}, {Automatic, 24}},
FrontEndVersion->"10.0 for Mac OS X x86 (32-bit, 64-bit Kernel) (June 27, \
2014)",
StyleDefinitions->"Default.nb"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{
 "eq:AxisRangeMinMax"->{
  Cell[17696, 524, 620, 17, 51, "NumberedEquation",
   CellTags->"eq:AxisRangeMinMax"]},
 "eq:Boundaries"->{
  Cell[141502, 4360, 859, 30, 81, "NumberedEquation",
   CellTags->"eq:Boundaries"]},
 "eq:CombinedRotationRange"->{
  Cell[159680, 4921, 1799, 58, 75, "NumberedEquation",
   CellTags->"eq:CombinedRotationRange"]},
 "eq:DiscardedRegionBounds"->{
  Cell[138047, 4249, 2867, 92, 57, "NumberedEquation",
   CellTags->"eq:DiscardedRegionBounds"]},
 "eq:disFunction"->{
  Cell[130860, 3994, 954, 35, 63, "NumberedEquation",
   CellTags->"eq:disFunction"]},
 "eq:ErfDefinition"->{
  Cell[128170, 3908, 984, 36, 63, "NumberedEquation",
   CellTags->"eq:ErfDefinition"]},
 "eq:generalisedPerturbation"->{
  Cell[112059, 3480, 3906, 112, 99, "NumberedEquation",
   CellTags->"eq:generalisedPerturbation"]},
 "eq:L"->{
  Cell[21173, 642, 2344, 72, 157, "NumberedEquation",
   CellTags->"eq:L"]},
 "eq:LowHigh"->{
  Cell[134542, 4112, 611, 21, 45, "NumberedEquation",
   CellTags->"eq:LowHigh"]},
 "eq:lxyPixel"->{
  Cell[35375, 1053, 2181, 78, 73, "NumberedEquation",
   CellTags->"eq:lxyPixel"]},
 "eq:newCompressionRatio"->{
  Cell[163491, 5052, 972, 31, 53, "NumberedEquation",
   CellTags->"eq:newCompressionRatio"]},
 "eq:newGradient"->{
  Cell[162196, 5008, 978, 31, 51, "NumberedEquation",
   CellTags->"eq:newGradient"]},
 "eq:NormRxyz3Inverse"->{
  Cell[26704, 811, 1528, 43, 53, "NumberedEquation",
   CellTags->"eq:NormRxyz3Inverse"]},
 "eq:NormRxyz4"->{
  Cell[33036, 991, 946, 25, 73, "NumberedEquation",
   CellTags->"eq:NormRxyz4"]},
 "eq:PreservedRegion"->{
  Cell[142536, 4402, 845, 27, 59, "NumberedEquation",
   CellTags->"eq:PreservedRegion"]},
 "eq:PreservedRegionConsts"->{
  Cell[145789, 4526, 540, 16, 59, "NumberedEquation",
   CellTags->"eq:PreservedRegionConsts"]},
 "eq:PreservedRegionGen"->{
  Cell[146641, 4555, 2782, 94, 53, "NumberedEquation",
   CellTags->"eq:PreservedRegionGen"]},
 "eq:0to1"->{
  Cell[133484, 4072, 844, 28, 63, "NumberedEquation",
   CellTags->"eq:0to1"]},
 "sec:CameraRGB"->{
  Cell[2052, 60, 141, 2, 44, "Subsection",
   CellTags->"sec:CameraRGB"]},
 "sec:ConstructingANewColorSpace"->{
  Cell[742, 29, 138, 2, 64, "Section",
   CellTags->"sec:ConstructingANewColorSpace"]},
 "sec:ERF"->{
  Cell[124966, 3831, 117, 2, 44, "Subsection",
   CellTags->"sec:ERF"]},
 "sec:Linear"->{
  Cell[124193, 3809, 97, 2, 44, "Subsection",
   CellTags->"sec:Linear"]},
 "sec:Partition"->{
  Cell[123729, 3795, 105, 2, 44, "Subsection",
   CellTags->"sec:Partition"]},
 "sec:PreservationOfColorInformation"->{
  Cell[120759, 3740, 145, 2, 64, "Section",
   CellTags->"sec:PreservationOfColorInformation"]},
 "sec:RotationMatrix"->{
  Cell[3892, 100, 620, 10, 106, "Text",
   CellTags->"sec:RotationMatrix"]}
 }
*)
(*CellTagsIndex
CellTagsIndex->{
 {"eq:AxisRangeMinMax", 187169, 5793},
 {"eq:Boundaries", 187278, 5796},
 {"eq:CombinedRotationRange", 187395, 5799},
 {"eq:DiscardedRegionBounds", 187524, 5802},
 {"eq:disFunction", 187643, 5805},
 {"eq:ErfDefinition", 187753, 5808},
 {"eq:generalisedPerturbation", 187875, 5811},
 {"eq:L", 187987, 5814},
 {"eq:LowHigh", 188081, 5817},
 {"eq:lxyPixel", 188182, 5820},
 {"eq:newCompressionRatio", 188295, 5823},
 {"eq:newGradient", 188411, 5826},
 {"eq:NormRxyz3Inverse", 188524, 5829},
 {"eq:NormRxyz4", 188634, 5832},
 {"eq:PreservedRegion", 188742, 5835},
 {"eq:PreservedRegionConsts", 188864, 5838},
 {"eq:PreservedRegionGen", 188989, 5841},
 {"eq:0to1", 189098, 5844},
 {"sec:CameraRGB", 189198, 5847},
 {"sec:ConstructingANewColorSpace", 189310, 5850},
 {"sec:ERF", 189412, 5853},
 {"sec:Linear", 189502, 5856},
 {"sec:Partition", 189597, 5859},
 {"sec:PreservationOfColorInformation", 189717, 5862},
 {"sec:RotationMatrix", 189839, 5865}
 }
*)
(*NotebookFileOutline
Notebook[{
Cell[CellGroupData[{
Cell[580, 22, 137, 3, 109, "Chapter"],
Cell[CellGroupData[{
Cell[742, 29, 138, 2, 64, "Section",
 CellTags->"sec:ConstructingANewColorSpace"],
Cell[883, 33, 236, 4, 49, "Text"],
Cell[1122, 39, 559, 9, 106, "Text"],
Cell[1684, 50, 343, 6, 68, "Text"],
Cell[CellGroupData[{
Cell[2052, 60, 141, 2, 44, "Subsection",
 CellTags->"sec:CameraRGB"],
Cell[2196, 64, 305, 5, 68, "Text"],
Cell[2504, 71, 967, 14, 163, "Text"],
Cell[3474, 87, 272, 5, 68, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[3783, 97, 106, 1, 44, "Subsection"],
Cell[3892, 100, 620, 10, 106, "Text",
 CellTags->"sec:RotationMatrix"],
Cell[4515, 112, 5501, 183, 377, InheritFromParent],
Cell[10019, 297, 783, 21, 100, "Text"],
Cell[10805, 320, 16, 0, 30, "Text"],
Cell[10824, 322, 3029, 106, 177, "NumberedEquation"],
Cell[13856, 430, 211, 6, 32, "Text"],
Cell[14070, 438, 946, 21, 139, "Text"],
Cell[15019, 461, 1147, 24, 152, "Text"],
Cell[16169, 487, 707, 15, 103, "Text"],
Cell[16879, 504, 748, 15, 110, "Text"],
Cell[17630, 521, 63, 1, 30, "Text"],
Cell[17696, 524, 620, 17, 51, "NumberedEquation",
 CellTags->"eq:AxisRangeMinMax"],
Cell[18319, 543, 210, 7, 30, "Text"],
Cell[18532, 552, 303, 9, 38, "Text"],
Cell[18838, 563, 2147, 71, 376, "Text"],
Cell[20988, 636, 116, 1, 30, "Text"],
Cell[21107, 639, 63, 1, 30, "Text"],
Cell[21173, 642, 2344, 72, 157, "NumberedEquation",
 CellTags->"eq:L"],
Cell[23520, 716, 915, 23, 107, "Text"],
Cell[24438, 741, 145, 2, 30, "Text"],
Cell[24586, 745, 1849, 55, 91, InheritFromParent],
Cell[26438, 802, 197, 4, 49, "Text"],
Cell[26638, 808, 63, 1, 30, "Text"],
Cell[26704, 811, 1528, 43, 53, "NumberedEquation",
 CellTags->"eq:NormRxyz3Inverse"]
}, Open  ]],
Cell[CellGroupData[{
Cell[28269, 859, 92, 1, 44, "Subsection"],
Cell[28364, 862, 899, 15, 163, "Text"],
Cell[29266, 879, 412, 7, 87, "Text"],
Cell[CellGroupData[{
Cell[29703, 890, 94, 1, 35, "Subsubsection"],
Cell[29800, 893, 466, 7, 106, "Text"],
Cell[30269, 902, 2123, 74, 210, "Text"],
Cell[32395, 978, 619, 9, 125, "Text"],
Cell[33017, 989, 16, 0, 30, "Text"],
Cell[33036, 991, 946, 25, 73, "NumberedEquation",
 CellTags->"eq:NormRxyz4"],
Cell[33985, 1018, 737, 14, 110, "Text"],
Cell[34725, 1034, 628, 15, 95, "Text"],
Cell[35356, 1051, 16, 0, 30, "Text"],
Cell[35375, 1053, 2181, 78, 73, "NumberedEquation",
 CellTags->"eq:lxyPixel"],
Cell[37559, 1133, 559, 15, 53, "Text"],
Cell[38121, 1150, 16, 0, 30, "Text"],
Cell[38140, 1152, 1958, 56, 103, "NumberedEquation"],
Cell[40101, 1210, 1764, 51, 135, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[41902, 1266, 90, 1, 35, "Subsubsection"],
Cell[41995, 1269, 448, 10, 70, "Text"],
Cell[42446, 1281, 890, 25, 103, "Text"],
Cell[43339, 1308, 16, 0, 30, "Text"],
Cell[43358, 1310, 3358, 110, 177, "NumberedEquation"],
Cell[46719, 1422, 389, 7, 68, "Text"],
Cell[CellGroupData[{
Cell[47133, 1433, 103, 1, 28, "Item"],
Cell[47239, 1436, 123, 1, 28, "Item"],
Cell[47365, 1439, 105, 1, 28, "Item"]
}, Open  ]],
Cell[47485, 1443, 131, 3, 30, "Text"],
Cell[47619, 1448, 2627, 90, 115, "NumberedEquation"],
Cell[50249, 1540, 87, 1, 30, "Text"],
Cell[50339, 1543, 609, 18, 68, "Text"],
Cell[50951, 1563, 834, 26, 53, "Text"],
Cell[51788, 1591, 581, 22, 33, InheritFromParent],
Cell[52372, 1615, 69, 0, 30, "Text"],
Cell[52444, 1617, 774, 19, 93, "Text"],
Cell[53221, 1638, 2725, 87, 221, InheritFromParent],
Cell[55949, 1727, 2302, 64, 329, "Text"],
Cell[58254, 1793, 443, 13, 32, "Text"],
Cell[58700, 1808, 3198, 105, 107, InheritFromParent],
Cell[61901, 1915, 72, 1, 30, "Text"],
Cell[61976, 1918, 2193, 77, 107, InheritFromParent],
Cell[64172, 1997, 399, 12, 32, "Text"],
Cell[64574, 2011, 3936, 132, 169, InheritFromParent],
Cell[68513, 2145, 433, 14, 32, "Text"],
Cell[68949, 2161, 365, 9, 53, "Text"],
Cell[69317, 2172, 2544, 86, 136, "Text"],
Cell[71864, 2260, 3223, 121, 81, InheritFromParent],
Cell[75090, 2383, 185, 4, 49, "Text"],
Cell[75278, 2389, 4150, 149, 131, InheritFromParent],
Cell[79431, 2540, 466, 11, 70, "Text"],
Cell[79900, 2553, 2974, 78, 135, "Equation"],
Cell[82877, 2633, 436, 11, 51, "Text"],
Cell[83316, 2646, 416, 13, 51, "Text"],
Cell[83735, 2661, 808, 27, 38, "NumberedEquation"],
Cell[84546, 2690, 69, 1, 30, "Text"],
Cell[84618, 2693, 64, 1, 30, "Text"],
Cell[84685, 2696, 1450, 39, 69, "Equation"],
Cell[86138, 2737, 230, 5, 49, "Text"],
Cell[86371, 2744, 120, 3, 30, "Text"],
Cell[86494, 2749, 2477, 75, 274, "Text"],
Cell[88974, 2826, 418, 14, 55, "Text"],
Cell[89395, 2842, 4919, 127, 207, InheritFromParent],
Cell[94317, 2971, 3617, 117, 227, "Text"],
Cell[97937, 3090, 64, 1, 30, "Text"],
Cell[98004, 3093, 916, 25, 39, "Equation"],
Cell[98923, 3120, 434, 13, 33, "Text"],
Cell[99360, 3135, 64, 1, 30, "Text"],
Cell[99427, 3138, 878, 24, 29, "Equation"],
Cell[100308, 3164, 513, 17, 33, "Text"],
Cell[100824, 3183, 63, 1, 30, "Text"],
Cell[100890, 3186, 1867, 50, 107, "NumberedEquation"],
Cell[102760, 3238, 357, 10, 33, "Text"],
Cell[103120, 3250, 7513, 190, 345, InheritFromParent],
Cell[110636, 3442, 582, 12, 89, "Text"],
Cell[111221, 3456, 835, 22, 93, "Text"],
Cell[112059, 3480, 3906, 112, 99, "NumberedEquation",
 CellTags->"eq:generalisedPerturbation"],
Cell[115968, 3594, 355, 12, 32, "Text"],
Cell[116326, 3608, 2247, 67, 166, "Text"],
Cell[118576, 3677, 2122, 56, 203, "Text"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[120759, 3740, 145, 2, 64, "Section",
 CellTags->"sec:PreservationOfColorInformation"],
Cell[120907, 3744, 584, 9, 106, "Text"],
Cell[121494, 3755, 1032, 15, 182, "Text"],
Cell[122529, 3772, 851, 12, 144, "Text"],
Cell[123383, 3786, 321, 5, 68, "Text"],
Cell[CellGroupData[{
Cell[123729, 3795, 105, 2, 44, "Subsection",
 CellTags->"sec:Partition"],
Cell[123837, 3799, 319, 5, 68, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[124193, 3809, 97, 2, 44, "Subsection",
 CellTags->"sec:Linear"],
Cell[124293, 3813, 636, 13, 106, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[124966, 3831, 117, 2, 44, "Subsection",
 CellTags->"sec:ERF"],
Cell[125086, 3835, 726, 11, 125, "Text"],
Cell[125815, 3848, 483, 7, 87, "Text"],
Cell[126301, 3857, 654, 10, 125, "Text"],
Cell[126958, 3869, 1190, 35, 91, "Text"],
Cell[128151, 3906, 16, 0, 30, "Text"],
Cell[128170, 3908, 984, 36, 63, "NumberedEquation",
 CellTags->"eq:ErfDefinition"],
Cell[129157, 3946, 623, 19, 51, "Text"],
Cell[129783, 3967, 1055, 23, 133, "Text"],
Cell[130841, 3992, 16, 0, 30, "Text"],
Cell[130860, 3994, 954, 35, 63, "NumberedEquation",
 CellTags->"eq:disFunction"]
}, Open  ]],
Cell[CellGroupData[{
Cell[131851, 4034, 139, 1, 44, "Subsection"],
Cell[131993, 4037, 936, 15, 144, "Text"],
Cell[CellGroupData[{
Cell[132954, 4056, 111, 1, 35, "Subsubsection"],
Cell[133068, 4059, 394, 9, 70, "Text"],
Cell[133465, 4070, 16, 0, 30, "Text"],
Cell[133484, 4072, 844, 28, 63, "NumberedEquation",
 CellTags->"eq:0to1"],
Cell[134331, 4102, 189, 6, 32, "Text"],
Cell[134523, 4110, 16, 0, 30, "Text"],
Cell[134542, 4112, 611, 21, 45, "NumberedEquation",
 CellTags->"eq:LowHigh"],
Cell[135156, 4135, 1072, 42, 51, "Text"],
Cell[136231, 4179, 1794, 66, 37, InheritFromParent],
Cell[138028, 4247, 16, 0, 30, "Text"],
Cell[138047, 4249, 2867, 92, 57, "NumberedEquation",
 CellTags->"eq:DiscardedRegionBounds"]
}, Open  ]],
Cell[CellGroupData[{
Cell[140951, 4346, 129, 1, 35, "Subsubsection"],
Cell[141083, 4349, 397, 7, 87, "Text"],
Cell[141483, 4358, 16, 0, 30, "Text"],
Cell[141502, 4360, 859, 30, 81, "NumberedEquation",
 CellTags->"eq:Boundaries"],
Cell[142364, 4392, 150, 6, 32, "Text"],
Cell[142517, 4400, 16, 0, 30, "Text"],
Cell[142536, 4402, 845, 27, 59, "NumberedEquation",
 CellTags->"eq:PreservedRegion"],
Cell[143384, 4431, 870, 32, 51, "Text"],
Cell[144257, 4465, 1510, 57, 37, InheritFromParent],
Cell[145770, 4524, 16, 0, 30, "Text"],
Cell[145789, 4526, 540, 16, 59, "NumberedEquation",
 CellTags->"eq:PreservedRegionConsts"],
Cell[146332, 4544, 287, 7, 51, "Text"],
Cell[146622, 4553, 16, 0, 30, "Text"],
Cell[146641, 4555, 2782, 94, 53, "NumberedEquation",
 CellTags->"eq:PreservedRegionGen"],
Cell[149426, 4651, 490, 11, 89, "Text"],
Cell[149919, 4664, 16, 0, 30, "Text"],
Cell[149938, 4666, 363, 11, 20, "NumberedEquation"],
Cell[150304, 4679, 860, 20, 110, "Text"],
Cell[151167, 4701, 16, 0, 30, "Text"],
Cell[151186, 4703, 1460, 46, 31, "NumberedEquation"]
}, Open  ]],
Cell[CellGroupData[{
Cell[152683, 4754, 89, 1, 35, "Subsubsection"],
Cell[152775, 4757, 932, 13, 163, "Text"],
Cell[153710, 4772, 776, 23, 53, "Text"],
Cell[154489, 4797, 1263, 31, 135, "Text"],
Cell[155755, 4830, 1857, 45, 211, "Text"],
Cell[157615, 4877, 2043, 40, 245, "Text"],
Cell[159661, 4919, 16, 0, 30, "Text"],
Cell[159680, 4921, 1799, 58, 75, "NumberedEquation",
 CellTags->"eq:CombinedRotationRange"],
Cell[161482, 4981, 230, 6, 51, "Text"],
Cell[161715, 4989, 459, 15, 51, "Text"],
Cell[162177, 5006, 16, 0, 30, "Text"],
Cell[162196, 5008, 978, 31, 51, "NumberedEquation",
 CellTags->"eq:newGradient"],
Cell[163177, 5041, 311, 9, 53, "Text"],
Cell[163491, 5052, 972, 31, 53, "NumberedEquation",
 CellTags->"eq:newCompressionRatio"]
}, Open  ]],
Cell[CellGroupData[{
Cell[164500, 5088, 143, 1, 35, "Subsubsection"],
Cell[164646, 5091, 357, 6, 68, "Text"],
Cell[165006, 5099, 16, 0, 30, "Text"],
Cell[165025, 5101, 3881, 129, 123, "NumberedEquation"],
Cell[168909, 5232, 815, 25, 106, "Text"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[169785, 5264, 92, 1, 64, "Section"],
Cell[169880, 5267, 1131, 28, 130, "Text"],
Cell[171014, 5297, 2153, 45, 266, "Text"],
Cell[CellGroupData[{
Cell[173192, 5346, 127, 1, 35, "Subsubsection"],
Cell[173322, 5349, 1662, 37, 192, "Text"],
Cell[174987, 5388, 1976, 70, 91, InheritFromParent],
Cell[176966, 5460, 690, 17, 74, "Text"],
Cell[177659, 5479, 407, 12, 36, "Text"],
Cell[178069, 5493, 2168, 70, 129, InheritFromParent],
Cell[180240, 5565, 817, 20, 91, "Text"],
Cell[181060, 5587, 1947, 66, 69, InheritFromParent],
Cell[183010, 5655, 895, 26, 78, "Text"],
Cell[183908, 5683, 1429, 48, 69, InheritFromParent],
Cell[185340, 5733, 1475, 44, 93, "Text"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)
